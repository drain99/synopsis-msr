\section{Proof Discharge Algorithm through Examples}
\label{sec:syn-examples}
This section demonstrates our proof discharge algorithm through example programs
that construct and traverse a linked list respectively. Our equivalence checker has the property
that it is safe to return false (i.e. disproven) for all proof obligations. Keeping this in mind,
our proof discharge algorithm is designed to be {\em sound} i.e. (a) whenever it evaluates a proof obligation
to true (i.e. proven), the actual proof obligation must also be proven and (b) whenever it returns
false with a set of counterexamples, the counterexamples must falsify the actual proof obligation.
However, it is possible for our proof discharge algorithm to return false (without a counterexample)
even if the actual proof obligation is true.
Our equivalence checking algorithm also ensures that, for an invariant
$\phi_s=({\tt \phi^{1}_s \land \phi^{2}_s \land ... \land \phi^{k}_s})$,
at any node $s$ of a product-CFG,
if a \recursiveRelation{} appears in $\phi_s$, it
must be one of $\phi^{1}_s$, $\phi^{2}_s$, ..., or $\phi^{k}_s$. We call
this the {\em conjunctive \recursiveRelation{}} property of an invariant $\phi_s$.

A proof obligation
$\hoareTriple{\phi_s}{e}{\phi_d}$, where $e=(\rho_S,\rho_C)$,
gets lowered using
${\tt WP}_{e}(\phi_d)$ (as shown in \cref{eqn:firstOrderFormula}) to a first-order logic formula of the following form:
\begin{equation}
\label{eqn:proofObligationShape}
({\tt \eta^{l}_1 \land \eta^{l}_2 \land ... \land \eta^{l}_m}) \Rightarrow ({\tt \eta^{r}_1 \land \eta^{r}_2 \land ... \land \eta^{r}_n})
\end{equation}
% In this formula,
% the {\tt LHS} and {\tt RHS} are
% written as conjunctions of $\eta^{l}_i$ and $\eta^{r}_j$ respectively (for $1\leq i\leq m$, $1\leq j\leq n$).
% Each $\eta^{r}_j$ relation is obtained from
% ${\tt WP}_{e}(\phi^{j}_d)$, where $\phi_d=({\tt \phi^{1}_d \land \phi^{2}_d \land ... \land \phi^{n}_d})$.
Thus, due to the conjunctive \recursiveRelation{} property of $\phi_s$ and $\phi_d$, any
\recursiveRelation{} in \cref{eqn:proofObligationShape} must appear as
one of $\eta^{l}_i$ or $\eta^{r}_j$.
To simplify proof obligation discharge,
we break a first-order logic proof obligation $P$ of the form in \cref{eqn:proofObligationShape}
into multiple smaller proof obligations
of the form
$P_j:({\tt LHS}\Rightarrow{\tt \eta^{r}_j})$, for $j=1..n$. Each proof obligation
$P_j$ is then discharged separately.  We call this conversion from
a bigger query to multiple smaller queries, {\em RHS-breaking}.

%We say that two relations $\eta_1$ and $\eta_2$ {\em interfere}, written
%$\eta_1 \interfere{} \eta_2$,
%iff the intersection
%of the sets of free variables mentioned in $\eta_1$ and $\eta_2$
%is non-empty.  For example, $a\indEq{}b$ and $c\indEq{}d$
%do not interfere, but $a\indEq{}b$ and $c\indEq{}{\tt LCons}(0,b)$ interfere.
%
%In a proof obligation of the form in \cref{eqn:proofObligationShape},
%two relations $\eta_1$ and $\eta_2$ {\em transitively interfere} iff
%there exists a relation $\eta_3$ in the proof
%obligation such that $\eta_1\interfere{}\eta_3$ and $\eta_3\interfere{}\eta_2$.
%This notion of transitive interference can be lifted
%to Hoare triples: in a proof obligation $\{\phi_s\}(e)\{\phi_d\}$,
%where $\phi_{s}=\phi^{1}_s\land...\phi^{k}_{s}$ and $\phi_{d}=\phi^{1}_d\land...\phi^{n}_{d}$,
%an {\tt LHS} conjunctive clause $\phi^{i}_s$ transitively
%interferes with an {\tt RHS} conjunctive clause $\phi^{j}_d$ iff
%$\phi^{i}_s$
%transitively interferes with ${\tt WP}_{e}(\phi^{j}_d)$ in
%the lowered first-order logic formula.

%We provide a sound (but imprecise) proof discharge
%algorithm that converts
%a proof obligation generated by our equivalence
%checker into a series of SMT queries.
%Our
%algorithm begins
%by categorizing a proof obligation
%into three categories, and each
%category is discussed separately
%in subsequent sections.  These categories are created
%based on an iterative unrolling and unification
%procedure, which we describe next.
%We use an unroll parameter $k$ for
%our categorization.
\subsection[Categorization of Proof Obligations]{Categorization of Proof Obligations based on \\Decomposition of Recursive Relations}
\label{sec:syn-cat-decomp}
Before diving into the proof discharge algorithm, we start with decomposition of \recursiveRelations{}.
Decomposition is a key procedure in multiple components of our proof discharge algorithm.
\begin{equation}
\label{eqn:specDeconstruct}
U_S: {\tt l\ =\ \underline{if}\ l}\ is\ {\tt LNil\ \ \underline{then}\ \ LNil\ \ \underline{else}\ \ LCons(l.val,l.tail)}
\end{equation}
A \recursiveRelation{} of the form $l_1 \indEq{} l_2$ can be {\em decomposed} into an
equivalent set of {\em decomposition clauses}, each of the form {\small $(P \rightarrow A = B)$ or $(P \rightarrow A \indEq{} B)$}.
The primary algorithm behind decomposition is a specialized unification procedure under a term rewriting
system $E$. $E$ allows rewriting of top-level lifting constructors by their definitions (e.g., \cref{eqn:clist})
as well as expansion of ADT variables using the \sumDtor{} operator as shown in \cref{eqn:specDeconstruct}.
Unification proceeds by iteratively (1) unifying the structurs created by the ADT value constructors as well as the \sumDtor{}
operator and (2) expanding the current subterms using the rewriting rules in $E$ as needed.
For example, \sumDtorExpr{$c_1$}{${\tt LNil}$}{${\tt LCons}(0,l_S)$}$\indEq{}$\sumDtorExpr{$c_2$}{${\tt LNil}$}{${\tt LCons}(i_C,{\tt Clist}_m^{\tt lnode}(l_C))$}
decomposes into $\bigwedge\{c_1=c_2, (c_1 \land c_2) \rightarrow 0=i_C, (c_1 \land c_2) \rightarrow l_S \indEq{} {\tt Clist}_m^{\tt lnode}(l_C)\}$.
Similarly, the decomposition of $l_S\indEq{}{\tt LCons}(42,{\tt Clist}_m^{\tt lnode}(l_C))$ is given by
$\bigwedge \{l_S\ {\tt is}\ {\tt LCons}, (l_S\ {\tt is}\ {\tt LCons}) \rightarrow (l.val=42), (l_S\ {\tt is}\ {\tt LCons}) \rightarrow (l.next \indEq{} {\tt Clist}_m^{\tt lnode}(l_C))\}$.
We {\em decompose} a proof obligation $P$ by decomposing each \recursiveRelation{} in $P$.

We {\em unroll an expression $e$} with respect to $E$ containing rules of the form $r_i \Rightarrow s_i$ by substituting
all occurances of $r_i$ in $e$ with $s_i$ for each $i$ and decomposing it. More generally, the $k$-unrolling of $e$ is found
by unrolling the $(k-1)$-unrolling of $e$ recursively. For a first order logic proof obligation $P:{\tt LHS}\Rightarrow{\tt RHS}$,
we identify its $k$-unrolling (for a fixed unrolling parameter $k$). After unrolling, we eliminate those
decomposition clauses $(P_i \rightarrow X_i)$ whose $P_i$ evaluates to {\tt false} under the {\tt LHS} ignoring all \recursiveRelations{}.
For example, the one-unrolling of $P:{\tt LHS} \Rightarrow l_S \indEq{} {\tt Clist}_m^{\tt lnode}(0)$, after simplification, yields
$P': {\tt LHS} \Rightarrow l_S\ {\tt is}\ {\tt LNil}$. We categorize a proof obligation $P$ based on this $k$-unrolled form of $P$ as follows:
\vspace{-10px}
\begin{itemize}
\setlength{\itemsep}{0px}
\item Type I: $k$-unrolling of $P$ does not contain \recursiveRelations{}
\item Type II: $k$-unrolling of $P$ contains \recursiveRelations{} only in the {\tt LHS}
\item Type III: $k$-unrolling of $P$ contains \recursiveRelations{} in the {\tt RHS}
\end{itemize}
\vspace{-10px}
Next, we briefly describe the key ideas for each of the three types of proof obligations in \cref{sec:syn-cat1,sec:syn-cat2,sec:syn-cat3}.

\input{chapters/figures/figSumListSpecIRAndCIR.tex}
\vspace{-10px}
\subsection{Handling Type I Proof Obligations}
\label{sec:syn-cat1}
In \cref{fig:llAllocProductCFG}, consider a proof obligation generated
across the product-CFG edge ${\tt (S0:C0) \rightarrow (S3:C3)}$
while checking if the ${\small \circled{I4}}$ invariant in \cref{tab:llproductInv}
holds at {\tt (S3:C3)}:
$\hoareTriple{\phi_{{\tt S0:C0}}}{{\tt S0\rightarrow S3}, {\tt C0\rightarrow C3}}{l_{S}\indEq{}{\tt Clist }^{{\tt lnode}}_{m}(l_{C})}$.
The precondition $\phi_{{\tt S0:C0}}\equiv(n_S=n_C)$ does not contain
a \recursiveRelation{}.
When lowered to first-order logic through {\tt WP$_{{\tt S0\rightarrow S3},{\tt C0\rightarrow C3}}$}, this translates to
``$(n_S=n_C)\Rightarrow({\tt LNil}\indEq{}{\tt Clist^{{\tt lnode}}_{m}(0)})$''.
Here, {\tt LNil} is obtained for {\tt l$_{S}$} and {\tt 0} (null) is
obtained for {\tt l$_C$}.
The one-unrolled form of this proof obligation yields
$(n_S=n_C)\Rightarrow{}{\tt LNil}\indEq{}{\tt LNil}$ which trivially resolves to true.

Consider another example of a proof obligation,
$\hoareTriple{\phi_{{\tt S0:C0}}}{{\tt S0\rightarrow S3\rightarrow S5\rightarrow S3}, \\ {\tt C0\rightarrow C3}}{l_{S}\indEq{}{\tt Clist}^{{\tt lnode}}_{m}(l_{C})}$.
Notice, we have changed the path in $S$ to ${\tt S0\rightarrow S3\rightarrow S5\rightarrow S3}$ here.
In this case, the corresponding first-order logic condition evaluates
to: ``$(n_S=n_C)\Rightarrow({\tt LCons(0, LNil)}\indEq{}{\tt Clist}^{{\tt lnode}}_{m}(0))$''.
One-unrolling of this proof obligation converts
${\tt Clist^{{\tt lnode}}_{m}(0)}$ to {\tt LNil}, and
decomposes {\tt RHS} into {\tt false}.
The proof obligation is further discharged using an SMT solver
which provides a counterexample (model) that evaluates the
formula to false. For example, the counterexample {\tt \{ n$_S$ $\mapsto$ 42, n$_C$ $\mapsto$ 42 \} }
evaluates this formula to false.
% because
% this fails to unify (during decomposition), it evaluates to false.
% When a
% proof obligation evaluates to false, the SMT solver
% provides a counterexample (model) that evaluates the condition
% to false.  For example, the counterexample {\tt n$_S$=n$_C$=42}
% evaluates this condition to false.
These counterexamples
assist in faster convergence
of our invariant inference and correlation search procedures as part of the \toolName{} tool.
% Thus, we unify the structure and
% values of the \SpecL{} objects on both sides of
% the $\sim$ operator (after $k$ unrollings), and discharge the resulting
% proof obligations (that relate bitvector and array values) using an SMT solver.
% Please refer to {\tt Chapter \ThesisChapterAlgo{}} of the thesis for
% the intricacies of (a) translation of the formlua to SMT logic and (b) reconstruction
% of counterexamples from the models returned by the SMT solver.
% Assuming a capable enough SMT solver,
% all proof obligations in Type I can be discharged precisely, i.e.,
% we can always decide whether $P$ evaluates to true or false. If it
% evaluates to false, we also obtain a counterexample.

\input{chapters/figures/figSumListProductCFGAndInvs.tex}

\subsection{Handling Type II Proof Obligations}
\label{sec:syn-cat2}
Consider the pair of programs in \cref{fig:llTraverseSpec,fig:llTraverseC}
that traverse a list to compute the sum of all elements.
The corresponding product-CFG and its node
invariants that ensure observable
equivalence are shown in \cref{fig:llTraverseProduct,fig:llTraverseProductInv}.

Consider the proof obligation originating due to \circled{\small I2} invariant across edge ({\tt S2:C2})$\rightarrow$({\tt S2:C2}) in \cref{fig:llTraverseProduct}:
$\hoareTriple{\phi_{{\tt S2:C2}}}{{\tt S2\rightarrow S5\rightarrow S2}, {\tt C2\rightarrow C4\rightarrow C2}}{um_{S} = sum_{C}}$, where
the node invariant $\phi_{{\tt S2:C2}}$ contains
the \recursiveRelation{} $l_{S}\indEq{}{\tt Clist}^{{\tt lnode}}_{m}(l_{C})$.
The corresponding (simplified) first-order logic condition for this
proof obligation is:
($l_{S}\indEq{}Clist^{{\tt lnode}}_{m}(l_{C}) \land {\tt sum}_S={\tt sum}_C \land \neg({\tt l_S}\ is\ {\tt LNil}) \land {\tt l_C\neq0}) \Rightarrow (({\tt sum}_S + l_S.val) = (sum_C + \structPointer{l}{m}{{\tt lnode}}{val}))$.
We fail to remove the \recursiveRelation{} on the {\tt LHS} even after
$k$-unrolling for any finite depth $k$ because both sides of $\indEq{}$
represent list values of arbitrary length.
In such a scenario, we do not know of an efficient
SMT encoding for the \recursiveRelation{} ($l_{S}\indEq{}Clist^{{\tt lnode}}_{m}(l_{C})$).
Ignoring this \recursiveRelation{} will incorrectly (although soundly) evaluate
the proof obligation to {\tt false}; however, for a successful equivalence
proof, we need
the proof discharge algorithm to evaluate it to true. Let's call this
requirement \circled{\small R1}.

Now, consider the proof obligation formed by correlating two iterations
of the loop in program $S$ with one iteration of the loop in program $C$,
$\hoareTriple{phi_{{\tt S2:C2}}}{{\tt S2\rightarrow S5\rightarrow S2\rightarrow S5\rightarrow S2}, {\tt C2\rightarrow C4\rightarrow C2}}{sum_{S} = sum_{C}}$.
Similar to the last proof obligation, its equivalent first-order logic condition contains a \recursiveRelation{} in the {\tt LHS}.
Clearly, this proof obligation should evaluate to {\tt false}.
% The equivalent
% first-order logic condition is:
% ($l_{S}\indEq{}Clist^{{\tt lnode}}_{m}(l_{C}) \land {\tt sum}_S={\tt sum}_C \land \neg({\tt l_S}\ is\ {\tt LNil}) \land \neg({\tt l_S.tail}\ is\ {\tt LNil})) \Rightarrow (({\tt sum}_S + l_S.val + l_S.tail.val) = (sum_C + \structPointer{l}{m}{{\tt lnode}}{val}))$.  After one unrolling
% of $l_{S}\indEq{}Clist^{{\tt lnode}}_{m}(l_{C})$,
% this proof obligation evaluates to false.
Whenever a proof
obligation evaluates to {\tt false}, we
expect an ideal proof discharge algorithm to generate a
counterexample that falsifies the proof obligation.
Let's call this
requirement \circled{\small R2}.
Recall that such counterexamples help in faster
convergence of our invariant inference and correlation algorithms.

To tackle requirements \circled{\small R1} and \circled{\small R2},
our proof discharge algorithm converts the original proof obligation $P: \hoareTriple{\phi_s}{e}{\phi_d}$
into two approximated proof obligations $(P_{{\tt pre-o}}: \hoareTriple{\phi^{o_{d_1}}_s}{e}{\phi_d})$
and $(P_{{\tt pre-u}}: \hoareTriple{\phi^{u_{d_2}}_s}{e}{\phi_d})$.
Here $\phi^{o_{d_1}}_s$ and
$\phi^{u_{d_2}}_s$ represent the over- and under-approximated
versions of precondition $\phi_s$ respectively, and $d_1$ and $d_2$ represent
{\em depth} parameters that indicate the degree of over- and
under-approximation. We over (under) approximate a predicate by over (under)
approximating each of its constituent \recursiveRelation{}.
The $d$-depth over- and under-approximations of a \recursiveRelation{} $l_1\indEq{}l_2$
are written as $l_1\indEqDepth{d}l_2$ and $l_1\indEqUapprox{d}l_2$ respectively.
To define these two operators, we start with the notion of {\em depth of an ADT value}.
For each node in the tree representation of the term representing a value $v$,
we assign a depth value equal to the number of ADT value constructors in the path
to the root node. The depth of an ADT value is the maximum of the depths of all nodes in
its term. For example, the value ${\tt LCons}(2, {\tt LCons}(4, {\tt LNil}))$ has a depth
of 2. $l_1\indEqDepth{d}l_2$ asserts equality of the corresponding structures and values
up to a depth of $d$. $l_1\indEqUapprox{d}l_2$ asserts equality of the corresponding structures
and values up to a depth of $d$ and bounds the depths of $l_1$ and $l_2$ to a maximum of $d$.
$l_1\indEqUapprox{d}l_2$ is equivalent to $l_1\indEqDepth{d}l_2 \land \depthBound{d}{l_1} \land \depthBound{d}{l_2}$,
where $\depthBound{d}{l}$ asserts that $l$ has a maximum depth of $d$.
Unlike \recursiveRelations{}, these operators only equate
scalar (bitvector, bool typed) expressions and can be encoded in SMT logic.
For example, the condition $l\indEqDepth{1}{\tt Clist}^{{\tt lnode}}_{m}({\tt p})$
reduces to the SMT-encodable predicate:
$
((l\ is\ {\tt LNil}) \Leftrightarrow {\tt (p = 0)}) \land (\neg(l\ is\ {\tt LNil})\Rightarrow(l{\tt.val}=\structPointer{p}{m}{{\tt lnode}}{val}))
$.
Similarly, $\depthBound{2}{l}$ is equivalent to
$(l\ is\ {\tt LNil}) \vee (\neg(l\ is\ {\tt LNil})\land(l{\tt .tail}\ is\ {\tt LNil}))$
and $\depthBound{2}{{\tt Clist}^{{\tt lnode}}_{m}({\tt p})}$
is equivalent to
$({\tt p}=0) \vee (\neg({\tt p}\neq 0)\land(\structPointer{p}{m}{\tt lnode}{next}=0))$.

Thus, for a {\em Type II} proof obligation $P: \hoareTriple{\phi_s}{e}{\phi_d}$,
we first submit the over-approximated proof obligation $(P_{{\tt pre-o}}$
and return true if it evaluates to true.
Otherwise, we submit the under-approximated proof obligation $(P_{{\tt pre-u}}$.
If it returns false, then we return false with the counterexample.
If both approximations fail, we soundly return false with no counterexamples.

Revisiting our examples,
the proof obligation $\hoareTriple{\phi_{{\tt S2:C2}}}{{\tt S2\rightarrow S5\rightarrow S2},\\ {\tt C2\rightarrow C4\rightarrow C2}}{sum_{S} = sum_{C}}$ is
provable using a depth-1 overapproximation of the
precondition $\phi_{{\tt S2:C2}}$.
% The depth-1 overapproximation retains the
% information that the first value in lists ${\tt l}_S$
% and ${\tt l}_C$ are equal, and that is sufficient to prove that
% the new values of $sum_{S}$ and $sum_{C}$ are also equal (given that the
% old values are equal, as encoded in $\phi_{{\tt S2:C2}}$).
Similarly, the proof obligation
$\hoareTriple{\phi_{{\tt S2:C2}}}{{\tt S2\rightarrow S5\rightarrow S2\rightarrow S5\rightarrow S2}, {\tt C2\rightarrow C4\rightarrow C2}}{sum_{S} = sum_{C}}$
evaluates to false (with a counterexample) using
a depth-2 underapproximation of the precondition $\phi_{{\tt S2:C2}}$.
The following is a possible counterexample for a depth-2 underapproximation.
% In the depth-2 underapproximate version, we try to prove that
% if the equal lists $l_S$ and ${\tt Clist}^{{\tt lnode}}_{m}(l_C)$
% have exactly two
% nodes\footnote{The underapproximation
% restricts both lists to have at most
% two nodes; the path condition for ${\tt S2\rightarrow S5\rightarrow S2\rightarrow S5\rightarrow S2}$ additionally
% restricts $l_S$ to have at least two nodes; together, this is equivalent to the list having
% exactly two nodes}, then
% the sum of the values in the two nodes of $l_S$ is equal to the
% value stored in the first node in {\tt l}$_C$.
% This proof obligation will return a counterexample that
% maps program variables to their concrete values. We show a
% possible counterexample to this proof obligation below.
%
% \begin{small}
% \begin{center}
% \begin{footnotesize}
% \begin{tabular}{cc|c}
% {\tt sum$_S$ $\mapsto$ 3} & {\tt sum$_C$ $\mapsto$ 3} & \multirow{3}{*}{
% $m$ $\mapsto$ $\Bigg($
% \begin{tabular}{l}
% {\tt 0x123} $\mapsto_{\tt lnode}$ (.value $\mapsto$ 42, .next $\mapsto$ {\tt 0x456}), \\
% {\tt 0x456} $\mapsto_{\tt lnode}$ (.value $\mapsto$ 43, .next $\mapsto$ {\tt 0x000}), \\
% () $\mapsto$ {\tt 77} \\
% \end{tabular}
% $\Bigg)$
% } \\
% \multicolumn{2}{l|}{{\tt l$_S$} $\mapsto$ {\tt LCons(42,LCons(43,LNil))}} \\
% \multicolumn{2}{l|}{{\tt l$_C$} $\mapsto$ {\tt 0x123}} \\
% \end{tabular}
% \end{footnotesize}
% \end{center}
% \end{small}
% \begin{center}
% \begin{footnotesize}
% \begin{tabular}{l@{ $\mapsto$ }l|l}
% {\tt sum$_S$} & {\tt 3} &
% \multirow{4}{*}{
% $m$ $\mapsto$ $\Bigg($
% \begin{tabular}{l}
% {\tt 0x123} $\mapsto_{\tt lnode}$ (.value $\mapsto$ 42, .next $\mapsto$ {\tt 0x456}), \\
% {\tt 0x456} $\mapsto_{\tt lnode}$ (.value $\mapsto$ 43, .next $\mapsto$ {\tt 0x000}), \\
% () $\mapsto$ {\tt 77} \\
% \end{tabular}
% $\Bigg)$
% }
% \\
% {\tt sum$_C$} & {\tt 3} \\
% ${\tt l}_S$   & {\tt LCons(42,LCons(43,LNil))} \\
% ${\tt l}_C$   & {\tt 0x123} \\
% \end{tabular}
% \end{footnotesize}
% \end{center}
\begin{small}
\begin{center}
\begin{tabular}{ll@{ $\mapsto$ }l}
\{ & {\tt sum$_S$} & {\tt 3},\\
   & {\tt sum$_C$} & {\tt 3},\\
   & ${\tt l}_S$ & {\tt LCons(42,LCons(43,LNil))},\\
   & ${\tt l}_C$ & {\tt 0x123},\\
   & $m$ & $\Bigg\{$
           \begin{tabular}{ll}
             & {\tt 0x123} $\mapsto_{\tt lnode}$ (.value $\mapsto$ 42, .next $\mapsto$ {\tt 0x456}),\\
              & {\tt 0x456} $\mapsto_{\tt lnode}$ (.value $\mapsto$ 43, .next $\mapsto$ 0),\\
              & () $\mapsto$ {\tt 77}\\
           \end{tabular}$\Bigg\}$ \\
\}\\
\end{tabular}
\end{center}
\end{small}
% This counterexample maps variables to values (e.g., {\tt sum}$_C$ maps to an {\tt i32} value {\tt 3}
% and {\tt l}$_S$ maps to a {\tt List} value {\tt LCons(42,LCons(43,LNil))}).
% It also maps the C program's memory state $m$ to an array that
% maps the regions starting at addresses {\tt 0x123} and {\tt 0x456} (regions of size
% `{\tt sizeof lnode}') to memory objects of type {\tt lnode} (with the
% {\tt value} and {\tt next} fields shown for each object). For all other addresses (except
% the ones for which an explicit mapping is available), $m$ maps them
% to the default byte-value {\tt 77} (shown
% as {\tt () $\mapsto$ 77}) in this counterexample.

% This counterexample satisfies the preconditions $l_S\indEqUapprox{2}{\tt Clist}^{{\tt lnode}}_{m}({\tt l}_C)$
% and $sum_S=sum_C$. Further, when the
% paths $({\tt S2\rightarrow S5\rightarrow S2\rightarrow S5\rightarrow S2}, {\tt C2\rightarrow C4\rightarrow C2})$
% are executed starting at the machine state represented by this counterexample, the resulting
% values of $sum_S$ and $sum_C$ are {\tt 3+42+43=88} and {\tt 3+42=45} respectively. Evidently, the
% counterexample falsifies the proof condition because these values are not equal (as required by the postcondition).

\subsection{Handling Type III Proof Obligations}
\label{sec:syn-cat3}
In \cref{fig:llAllocProductCFG}, consider a proof obligation generated
across the product-CFG edge ${\tt (S3:C5) \rightarrow (S3:C3)}$
while checking if the {\small $\circled{I4}$} invariant, $l_{S}\indEq{}Clist^{lnode}_{m}(l_{C})$,
holds at {\tt (S3:C3)}:
$\hoareTriple{\phi_{{\tt S3:C5}}}{{\tt S3\rightarrow S5\rightarrow S3}, {\tt C5\rightarrow C3}}{l_{S}\indEq{}Clist^{lnode}_{m}(l_{C})}$.
Here, a \recursiveRelation{} is present both in the precondition $\phi_{{\tt S3:C5}}$ ({\small \circled{I8}})
and in the postcondition ({\small \circled{I4}}) and we are unable to
remove them after $k$-unrolling.
When lowered to first-order logic
through {\tt WP$_{{\tt S3\rightarrow S5\rightarrow S3},{\tt C5\rightarrow C3}}$}, this translates to (showing only relevant
relations):
\begin{equation}
\begin{split}
\label{eqn:ex1cat3}
({\tt i}_S={\tt i}_C \land {\tt p}_C={\tt malloc()} \land {\tt l}_S \indEq{} {\tt Clist}_m^{{\tt lnode}}({\tt l}_C)) \\ \Rightarrow ({\tt LCons}({\tt i}_S, {\tt l}_S) \indEq{} {\tt Clist}_{m'}^{{\tt lnode}}({\tt p}_C))
\end{split}
\end{equation}
On the {\tt RHS} of this first-order logic formula, {\tt LCons(i$_S$, l$_S$)} is compared for
equality with {\tt Clist$_{m'}^{{\tt lnode}}$(p$_C$)}; here {\tt p$_C$}
represents the address of the newly allocated {\tt lnode} object (through {\tt malloc}) and $m'$
represents the C memory state after executing the writes at lines
{\tt C5} and {\tt C6} on the path {\tt C5$\rightarrow$C3},
i.e.,
\begin{equation}
\label{eqn:memstore}
m' \equiv m[\& (\structPointer{p_C}{m}{\tt lnode}{\tt val}) \leftarrow {\tt i}_C]_{\tt i32}[\& (\structPointer{p_C}{m}{\tt lnode}{next}) \leftarrow {\tt l}_C]_{\tt i32}
\end{equation}
Here, $m[{\tt a}\leftarrow{\tt v}]$ reprsents an array that is
equal to $m$ everywhere except at address {\tt a} which contains the value {\tt v}.
We also refer to
these memory writes that distinguish $m$ from $m'$, the {\em distinguishing writes}.

\subsubsection{LHS-to-RHS Substitution and RHS Decomposition}
We start by utilizing
the $\indEq{}$ relationships in the {\tt LHS} (antecedant) of ``$\Rightarrow$''
to rewrite \cref{eqn:ex1cat3}
so that the recursive {\tt List} values in its {\tt RHS} (consequent)
are substituted with the lifted $C$ values (lifted using
the {\tt Clist} constructor). Thus, we
rewrite \cref{eqn:ex1cat3} to:
%\begin{equation}\label{eqn:clistsEqualUnder}
%({\tt l}_S \indEq{} {\tt Clist}_m^{{\tt lnode}}({\tt l}_C)) \Rightarrow
%({\tt Clist}_m^{{\tt lnode}}({\tt l}_C) \indEq{} {\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C))
%\end{equation}
\begin{equation}
\label{eqn:ex2cat3}
\begin{split}
({\tt i}_S={\tt i}_C \land {\tt p}_C={\tt malloc()} \land {\tt l}_S \indEq{} {\tt Clist}_m^{{\tt lnode}}({\tt l}_C)) \\ \Rightarrow ({\tt LCons}({\tt i}_S, {\tt Clist}_m^{{\tt lnode}}({\tt l}_C)) \indEq{} {\tt Clist}_{m'}^{{\tt lnode}}({\tt p}_C))
\end{split}
\end{equation}
Next, we decompose the {\tt RHS} by decomposing the \recursiveRelation{} in the {\tt RHS}
followed by RHS-breaking. This process reduces \cref{eqn:ex1cat3} into the following
smaller proof obligations (showing only the
{\tt RHS}, the {\tt LHS} is the same as in \cref{eqn:ex1cat3}):
(1) $\neg({\tt p}_C=0)$,
(2) {\tt $\neg({\tt p}_C=0)$ $\rightarrow$ i$_S=(\structPointer{p_C}{m'}{\tt lnode}{\tt val})$}, and
(3) {\tt $\neg({\tt p}_C=0)$ $\rightarrow$ Clist$_{m}^{{\tt lnode}}$(l$_C$)$\indEq{}$Clist$_{m'}^{{\tt lnode}}$($\structPointer{p_C}{m'}{\tt lnode}{\tt next}$)}.
The first two proof obligations fall in {\em Type II} and
are discharged through over- and under-approximation schemes (as discussed
in \cref{sec:syn-cat2}). Note that the first proof obligation is provable due
to the $(C\ \  \mathrm{\tt fits})$ assumption which implies
that pointer returned by {\tt malloc} must be non-null.
For ease of exposition, we simplify the postcondition of the third proof obligation
using the $(C\ \  \mathrm{\tt fits})$ assumption and \cref{eqn:memstore} to:
% from
% {\small \tt $\neg({\tt p}_C=0)$ $\rightarrow$ (Clist$_{m}^{{\tt lnode}}$(l$_C$)$\indEq{}$Clist$_{m'}^{{\tt lnode}}$(p$_C\xrightarrow[]{m'}_{\mathrm{\tt lnode}}$next))}
% to
% {\tt (Clist$_{m}^{{\tt lnode}}$(l$_C$)$\indEq{}$Clist$_{m'}^{{\tt lnode}}$(l$_C$))}.
% This simplification is valid because {\tt l$_C$}
% is written
% to address {\tt \&(p$_C\xrightarrow[]{m'}_{\mathrm{\tt lnode}}$next)}
% in $m'$ (\cref{eqn:memstore}).
% Also, we have already
% shown that $\neg({\tt p}_C=0)$ holds.
% Thus, the third proof obligation can be rewritten as
% a \recursiveRelation{} between two lifted expressions:
\begin{equation}\label{eqn:clistPreserved}
{\tt Clist}_m^{\tt lnode}({\tt l}_C) \indEq{} {\tt Clist}_{m'}^{\tt lnode}({{\tt l}_C})
\end{equation}

Hence, we are interested in proving equality
between two {\tt List} values in $C$ under different memory states $m$ and $m'$.
%Note that in general this \recursiveRelation{} may be under an precondition.
Next, we show how the above can be reformulated as a bisimilarity check between
two programs.

% Thus,
% under an antecedant that ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$
% is recursively equal to a {\tt List} value {\tt l}$_S$ in \SpecL{},
% we are interested in proving
% ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C) \indEq{}
% {\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C)$.  We next show how this
% \recursiveRelation{} can be converted to a bisimulation proof.

%Informally, this proof obligation in \cref{eqn:clistPreserved} checks
%that the structure
%and values of the linked list pointed-to by {\tt l}$_C$
%in $m$ remain preserved even after the
%memory writes to the newly allocated node (in $m'$).
%At a minimum, such reasoning requires an alias analysis
%that confirms that the newly allocated node is isolated from
%the existing linked list nodes.  We discuss this in more
%detail in the following section.

\subsubsection{Equality of Values to Equivalence of Programs}
\label{sec:recursiveEqToBisim}
Consider a program that recursively calls the definition (body) of
${\tt Clist}^{\tt lnode}$ to deconstruct
${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$.
For example,
${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$
may yield a recursive call
to ${\tt Clist}_m^{{\tt lnode}}(\structPointer{{\tt l}_C}{m}{\tt lnode}{next})$
and so on, until the argument becomes zero.
This program essentially deconstructs ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$
into its terminal (scalar) values and reconstructs
a {\tt List} value equal to the value
represented by ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$.
We call this program a {\em reconstruction program} based
on the lifting constructor
${\tt Clist}^{{\tt lnode}}$.
% We call this program that deconstructs
% ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$
% into its components and reconstructs an output
% {\tt List} value,
% a {\em reconstruction program} based on the unrolling procedure of
% ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$.
%(using the unrolling procedure in \cref{eqn:clist}) until
%a null pointer is reached
%yields a sequence of
%${\tt Clist}_m^{{\tt lnode}}({\tt l}^0_C)$,
%${\tt Clist}_m^{{\tt lnode}}({\tt l}^1_C)$,
%${\tt Clist}_m^{{\tt lnode}}({\tt l}^2_C)$, ...
%values, where each
%{\tt l}$^i_C$ (for $i$=0,1,2,...)
%represents a C pointer in $m$ that is lifted
%to a {\tt List} value (using ${\tt Clist}_m^{{\tt lnode}}$)
%during this deconstruction. If this sequence is finite,
%its last value
%is {\tt LNil}.
%We call this series of C pointers
%${\tt l}^0_C$,
%${\tt l}^1_C$,
%${\tt l}^2_C$, ..., the {\tt Clist}$_m^{{\tt lnode}}$-reachable
%pointers of {\tt l}$^0_C$, or \Reachable{{\tt Clist}_m^{{\tt lnode}}}{${\tt l}^0_C$}.

%\begin{definition}
%A lifted ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C))$ value
%is {\em well-formed} iff there exists a {\tt List} value ${\tt l}_S$
%in the \SpecL{} program $S$ such that
%$({\tt l}_S \indEq{} {\tt Clist}_m^{{\tt lnode}}({\tt l}_C))$.
%\end{definition}
%
%\begin{lemma}\label{lemma:finitenessOfWellFormed}
%For a well-formed lifted
%value ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C))$,
%\Reachable{{\tt Clist}_m^{{\tt lnode}}}{${\tt l}^0_C$} is finite.
%\end{lemma}
%\begin{proof}
%\Cref{lemma:finitenessOfWellFormed} follows from the definition of well-formedness and the finiteness
%of any ADT value in the \SpecL{} language.
%\end{proof}
%
%\begin{theorem}\label{theorem:clistsEqual}
%For a well-formed lifted value ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C))$:
%\begin{gather*}
%{\tt Clist}_m^{{\tt lnode}}({\tt l}_C)
%\indEq{}
%{\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C)\\
%\Leftrightarrow\\
%(\ReachableMath{{\tt Clist}_m^{{\tt lnode}}}{{\tt l}_C} = \ReachableMath{{\tt Clist}_{m'}^{{\tt lnode}}}{{\tt l}_C}\ \ \land\\
%\forall_{{{\tt l}^i_C\in\ReachableMath{{\tt Clist}_m^{{\tt lnode}}}{{\tt l}_C}}}({\structPointer{l^i_C}{m}{s}{value}}={\structPointer{l^i_C}{m'}{s}{value}} \land\ {\structPointer{l^i_C}{m}{s}{next}}={\structPointer{l^i_C}{m'}{s}{next}}))
%\end{gather*}
%\end{theorem}
%\begin{proof}
%The proof proceeds by induction on the structure of the
%well-formed value ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C))$.
%The `{\tt l}$_C=0$' condition represents the base case.
%The induction step involves unifying the expansions of
%${\tt Clist}_m^{{\tt lnode}}$
%and
%${\tt Clist}_{m'}^{{\tt lnode}}$ obtained using \cref{eqn:clist}, and using the induction hypothesis.
%\end{proof}

% \begin{theorem}\label{theorem:clistsEqual}
% Under the antecedant
% $({\tt l}_S \indEq{} {\tt Clist}_m^{{\tt lnode}}({\tt l}_C))$:

% $({\tt Clist}_m^{{\tt lnode}}({\tt l}_C)
% \indEq{}
% {\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C))$
% holds iff a bisimulation relation
% exists between the reconstruction programs
% based on ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$
% and
% ${\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C)$.
% The bisimulation relation must ensure that the
% observables generated by both procedures are
% identical.
% \end{theorem}
% \begin{proof}\let\qed\relax
% The ``if'' case of this ``iff'' relation follows
% from noting that the observables of
% a reconstruction program are the
% generated {\tt List} values. Thus, a
% successful bisimulation
% check ensures equal
% {\tt List}
% values upon termination. Termination
% follows from the antecedant because
% \SpecL{} values (such as $l_S$) must be finite.

% The ``only if'' case
% follows from the unification of the
% unrolling procedure (in \cref{eqn:clist}) for
% ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$
% and
% ${\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C)$.

%The proof proceeds by induction on the structure of the
%${\tt Clist}_m^{{\tt lnode}}({\tt l}_C))$.
%The base case is
%represented by the `{\tt l}$_C=0$' condition ---
%both deconstruction procedures terminate in this case (irrespective
%of the contents of $m$ and $m'$).
%The induction step involves unifying the expansions of
%${\tt Clist}_m^{{\tt lnode}}$
%and
%${\tt Clist}_{m'}^{{\tt lnode}}$ obtained using \cref{eqn:clist}, and using the induction hypothesis.
%At the induction step, we need to show that the first procedure takes the \underline{if} branch
%iff the second procedure takes the \underline{if} branch.  Further, we need
%to show that whenever the {\tt value}
%and {\tt next} fields are read
%in the {\tt lnode} objects pointed-to by {\tt l$_C$} in $m$ and $m'$
%respectively, they have identical contents.
% \end{proof}

\input{chapters/figures/figReconsCFGAndPCFG.tex}

To check if ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)
\indEq{} {\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C)$, we instead
check if a bisimulation relation exists
between the two respective reconstruction programs (assuming {\tt LHS} as the precondition at entries).
Similar to the top-level bisimulation search, we use a product-CFG to represent this bisimulation relation.
To distinguish this product-CFG from the top-level product-CFG that relates $S$ and $C$, we call
this product-CFG that relates two reconstruction programs, a {\em reconstruction product-CFG}
or {\em recons-PCFG} for short.
% To check bisimulation, we attempt to show that both reconstructions
% proceed in lockstep, and the invariants at
% each step of this lockstep execution ensure equal observables.
% We use a product-CFG to encode this lockstep execution --- to distinguish this
% product-CFG from the top-level product-CFG that relates $S$ and $C$, we call
% this product-CFG that relates two reconstruction programs, a {\em reconstruction product-CFG}
% or {\em recons-PCFG} for short.
% i.e., (1) the first deconstruction procedure evaluates
%an \underline{if} condition (e.g., {\tt l$_C$=0}) to true iff the second
%deconstruction procedure also evaluates the
%corresponding \underline{if} condition to true; and (2)
%the values observed by the first deconstruction procedure (e.g., {\tt lnode.value}
%which is used for constructing the observable {\tt List}) are identical to the
%ones observed by the second deconstruction procedure.
%As we have seen earlier, this lockstep execution can be encoded
%as a product-CFG: the invariants at the nodes of this product-CFG
%represent the conditions that must hold at the correlated
%PCs of this
%lockstep execution; for
%a successful bisimulation check, these invariants must ensure equal observables.
The reconstruction
program and the recons-PCFG for our {\tt Clist} example
are shown in \cref{fig:recons}.
Since both ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)$
and ${\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C)$ use the same
lifting constructor ${\tt Clist}^{\tt lnode}$, the PC-transition correlations of both programs
are trivially obtained
by unifying the program structure with itself. A node
is created in the recons-PCFG that
encodes the correlation of the entries to both programs,
we call this node the {\em recursive-node} in the
recons-PCFG, e.g., the
recursive node in \cref{fig:reconsPCFG} is {\tt R0:R0}. A recursive
call becomes a back-edge in the recons-PCFG that terminates at the
recursive-node.
A candidate
invariant at the recursive-node
is obtained by equating the pair of corresponding
{\tt l}$_C$ variables across the first and second
programs, i.e.,
${\tt l}^{fst}_C={\tt l}^{snd}_C$.
At the start of
both reconstruction
programs, ${\tt l}^{fst}_C={\tt l}^{snd}_C={\tt l}^{start}_C$
--- the
same ${\tt l}^{start}_C$ is passed to both reconstruction
programs, only the memory states $m$ and $m'$ are different.
The bisimulation check thus involves checking that
if the invariant
${\tt l}^{fst}_C={\tt l}^{snd}_C$
holds at the recursive-node,
then during one iteration of the static programs:
\vspace{-10px}
\begin{enumerate}
\setlength{\itemsep}{0px}
\item The \underline{if} condition
({\tt l$^{fst}_C=0$}) in the first program
is equal to the corresponding \underline{if}
condition ({\tt l$^{snd}_C=0$}) in the
second program.
\item If the \underline{if} condition
evaluates to false in both programs, then
the observable values (that are used in the
construction of the list) are equal, i.e.,
$(({\tt l}^{fst}_C\neq 0)\land({\tt l}^{snd}_C\neq 0))\Rightarrow (\structPointer{{\tt l}^{fst}_C}{m}{\tt lnode}{val}=
\structPointer{{\tt l}^{snd}_C}{m'}{\tt lnode}{val})$.
\item If the \underline{if} condition
evaluates to false in both programs, then
the invariant holds at the beginning
of the programs invoked through the
recursive call.
This involves checking equality
of the arguments to the recursive call, i.e.,
$(({\tt l}^{fst}_C\neq 0)\land({\tt l}^{snd}_C\neq 0))\Rightarrow \structPointer{{\tt l}^{fst}_C}{m}{\tt lnode}{next}
=
\structPointer{{\tt l}^{snd}_C}{m'}{\tt lnode}{next}$.
\end{enumerate}
\vspace{-7px}
The first check succeeds due to the invariant
${\tt l}^{fst}_C={\tt l}^{snd}_C$.
For the second and third checks, we additionally
need to reason that the memory objects
$\structPointer{{\tt l}^{fst}_C}{m}{\tt lnode}{val}$ and
$\structPointer{{\tt l}^{fst}_C}{m}{\tt lnode}{next}$ cannot
alias with the writes (in $m'$ in \cref{eqn:memstore})
to the newly allocated objects
$\structPointer{p_C}{m}{\tt lnode}{\tt val}$
and
$\structPointer{p_C}{m}{\tt lnode}{\tt next}$
We capture this aliasing information by running an intraprocedual allocation-site based points-to analysis on
the original $C$ program as well as the reconstruction programs being checked
for equivalence. Our points-to analysis also splits each allocation site region, say {\tt C4} in \cref{fig:llAllocCIR}, into
two regions {\tt C4}$_1$ and {\tt C4}$_2$, where {\tt C4}$_1$ represents the region of the most recent allocation and {\tt C4}$_2$
represents the region of all other allocations through ${\tt malloc_{C4}}$ respectively.
We write $p\pointsTo\{R_1,R_2\}$ to represent the condition that value $p$ {\em may point to}
an object belonging to one of the region labels $R_1$ or $R_2$ (but
may not point to any object outside of $R_1$ and $R_2$). We compute may-point-to information for
all program variables as well as the region labels themselves.
% For example, at the start of PC {\tt C7} in \cref{fig:llAllocCIR},
% {\tt i}$_C\pointsTo{}\emptyset$,
% {\tt n}$_C\pointsTo{}\{{\tt C4}_1\}$,
% and {\tt l}$_C\pointsTo{}\{{\tt C4}_{2+}\}$.
% Because the may-point-to analysis determines the
% sets of objects pointed-to by {\tt n}$_C$ and {\tt l}$_C$ to
% be disjoint ($\{{\tt C4_{1}}\}$ vs. $\{{\tt C4_{2+}}\}$), any
% memory accesses through {\tt n}$_C$ and {\tt l}$_C$
% cannot alias at {\tt C7} (for an access
% offset that is within the bounds of
% the allocation size `{\tt sizeof lnode}').
% Similarly, at PC {\tt C7}, we
% get
% ${\tt C4}_{1}\pointsTo{}\{{\tt C4}_{2+}\}$ and
% ${\tt C4}_{2+}\pointsTo{}\{{\tt C4}_{2+}\}$.
% The condition
% ${\tt C4}_{1}\pointsTo{}\{{\tt C4}_{2+}\}$
% holds because the {\tt next} pointer of the object
% pointed-to by ${\tt n}_C$ (which
% is a ${\tt C4}_1$ object) may point to
% a {\tt C4}$_{2+}$ object (e.g., object pointed-to
% by {\tt l}$_C$).
% Similarly, ${\tt C4}_{2+}\pointsTo{}\{{\tt C4}_{2+}\}$
% says that a pointer within a {\tt C4}$_{2+}$ object
% may point to a {\tt C4}$_{2+}$
% object (but not to a {\tt C4}$_1$ object).

% \subsubsection{Transferring points-to information to the recons-PCFG}
% \label{sec:pointsToAsInvariants}
% Recall that
% in \cref{sec:recursiveEqToBisim},
% we reduce a validity check of the condition
% ${\tt Clist}_m^{{\tt lnode}}({\tt l}_C)
% \indEq{} {\tt Clist}_{m'}^{{\tt lnode}}({\tt l}_C)$
% to a bisimulation check. Also, recall
% that we discharge the bisimulation check through the construction
% of a recons-PCFG that compares the unrolling procedure with itself (executing
% on memory states $m$ and $m'$).
% During this bisimulation check, we need to prove
% that for each execution
% of the unrolling procedure, $\structPointer{{\tt l}_C}{m}{\tt lnode}{\{val,next\}}$
% and $\structPointer{{\tt l}_C}{m'}{\tt lnode}{\{val,next\}}$\footnote{Here, we use the symbol {\tt l}$_C$ to
% refer to equal values {\tt l}$^{fst}_C$ and
% {\tt l}$^{snd}_C$.} are equal.
% To successfully discharge these proof obligations, it suffices
% to show ${\tt l}_C$ cannot alias with the memory writes that
% distinguish $m$ from $m'$.

Our points-to analysis on
the C program determines that at PC {\tt C5} of \cref{fig:llAllocCIR} (the start of
the product-CFG edge {\tt (S3:C5)$\rightarrow$(S3:C3)} across which the proof
condition is being evaluated),
the pointer to the {\em head}
of the list, i.e., ${\tt l}^{start}_C$
points to {\tt C4}$_{2+}$. It also determines that the distinguishing
writes modify memory regions belonging to {\tt C4}$_1$. 
Further, we get ${\tt C4}_{2+}\pointsTo{}\{{\tt C4}_{2+}\}$ at PC {\tt C5}.
However,
notice that these determinations only rule out aliasing of the list-head with
the distinguishing writes. We also need to confirm non-aliasing
of the internal nodes of the linked list with the distinguishing
writes.
For this, we need to identify a points-to invariant,
{\tt l}$_C^{snd}\pointsTo{}\{{\tt C4}_{2+}\}$, at the recursive-node
of the recons-PCFG
(shown in \cref{fig:reconsPCFG}).
To identify such points-to invariant, we run our points-to analysis
on the reconstruction programs (\cref{fig:reconsProg}) before comparing them for equivalence.
We use the results of the points-to analysis on $C$ at the PC where the proof obligation
is being discharged (e.g., {\tt C5} in \cref{fig:llAllocC}).
To see why {\tt l}$_C^{snd}\pointsTo{}\{{\tt C4}_{2+}\}$ is
an inductive invariant at the recursive-node:
(base case) The invariant holds
at entry to the recons-PCFG (because it holds for ${\tt l}^{start}_C$),
(induction step) If ${\tt l}_C^{snd}\pointsTo{}\{{\tt C4}_{2+}\}$
holds at the entry node,
it also holds at the start of a recursive call. This
follows from ${\tt C4}_{2+}\pointsTo{}\{{\tt C4}_{2+}\}$ (points-to information at PC {\tt C5}),
which ensures that $\structPointer{\tt l_C}{m'}{\tt lnode}{next}$ may point to only ${\tt C4}_{2+}$ objects.
% \vspace{-10px}
% \begin{itemize}
% \setlength{\itemsep}{0px}  
% \item (Base case) The invariant holds
% at entry to the recons-PCFG (because it holds for ${\tt l}^{start}_C$).
% \item (Induction step) If ${\tt l}_C^{snd}\pointsTo{}\{{\tt C4}_{2+}\}$
% holds at the entry node,
% it also holds at the start of a recursive call. This
% follows from ${\tt C4}_{2+}\pointsTo{}\{{\tt C4}_{2+}\}$ (points-to information at PC {\tt C5}),
% which ensures that $\structPointer{\tt l_C}{m'}{\tt lnode}{next}$ may point to only ${\tt C4}_{2+}$ objects.
% \end{itemize}
% \vspace{-10px}
During proof obligation discharge (e.g., during the bisimulation
check on recons-PCFG), the points-to invariants are encoded as SMT constraints.
This allows us to successfully
complete the bisimulation proof on the recons-PCFG, and
consequently successfully discharge the
proof obligation
$\hoareTriple{\phi_{{\tt S3:C5}}} \\ {{\tt S3\rightarrow S5\rightarrow S3}, {\tt C5\rightarrow C3}}{l_{S}\indEq{}Clist^{{\tt lnode}}_{m}(l_{C})}$ in \cref{tab:llproductInv}.
% The points-to analysis is described more formally
% in \cref{sec:pointsToFormal}.
\vspace{-3px}
\subsection{Summary of Proof Discharge Algorithm}
\vspace{-3px}
\label{sec:syn-algosummary}
Let $Solve({\tt LHS}, {\tt RHS}, k, d_o, d_u)$ be the top-level procedure for discharging proof obligations.
${\tt LHS}\Rightarrow{\tt RHS}$ represents the proof obligation, where $k$, $d_o$ and $d_u$ are the categorization parameter,
over- and under-approximation depths respectively.
$Solve$ returns either {\tt T} or {\tt F}(${\tt \Gamma}$) signifying proven and disproven respectively
where ${\tt \Gamma}$ is a set of counterexamples.
Without loss of generality, let {\tt RHS} be a single conjunctive
clause. Otherwise, it is broken into smaller queries through RHS-breaking as previously discussed. \Cref{algo:proofSummary}
gives a broad overview of our proof discharge algorithm.

\input{chapters/figures/figProofSummary.tex}


%Thus, as a part of the invariant inference procedure on the product-CFG
%for the decomposition programs, we also run our points-to analysis on the
%product-CFG to identify points-to invariants at the product-CFG
%nodes.  This improves precision, as shown in the example discussed
%above.
% \vspace{-5px}
% \subsubsection{Proof discharge algorithm for Type III obligations}
% \label{sec:cat3summary}

% Before the start of an equivalence check, a points-to analysis is run on the $C$ IR once.
% During the equivalence check,
% to discharge a Type III proof obligation $P: {\tt LHS}\Rightarrow{\tt RHS}$ (expressed
% in first-order logic), we first replace the recursive
% values of program $S$ in the {\tt RHS}
% with lifted C values, based on the equalities present in the {\tt LHS}, to
% obtain $P_2$.
% This is followed by decomposition and RHS-breaking of $P_2$.

% Upon successful decomposition, we
% obtain several smaller proof obligations.
% To prove $P$, we require all these smaller proof
% obligations to be provable. If any of these smaller proof obligations
% is not provable, we are unable to prove $P$.  If we obtain a counterexample
% to any of these smaller proof obligations, then that counterexample
% also falsifies $P$.
% Let $P_3$ represent any such smaller proof obligation.
% {\tt RHS} of $P_3$, being
% a decomposition clause,
% must relate atomic expressions on the {\tt RHS}.
% If $P_3$ relates two scalar values in the {\tt RHS}, then
% it is a Type II proof obligation and can be discharged
% using the algorithm in \cref{sec:cat2algo}.

% If $P_3$ relates two lifted
% expressions in
% the {\tt RHS},
% we check if the reconstruction
% programs of the two lifted ADT values being
% compared can be proven to be bisimilar (assuming that
% {\tt LHS} of $P_3$ holds at the correlated entry nodes
% in the recons-PCFG).
% To improve
% the bisimulation
% check's precision, we transfer the points-to information of the $C$ program
% (at the PC where the proof obligation is being discharged) to the entry
% of the reconstruction programs. The same points-to analysis is ran on the
% reconstruction programs to populate the points-to function at all PCs.

% These queries
% generated by a bisimulation check are discharged
% by a recursive call to the proof discharge procedure.
% The depth of these recursive calls to the
% proof discharge procedure is determined by
% the maximum {\em recursion nest depth} (similar
% to loop nest depth) of the decomposition
% program.

% If the bisimilarity check succeeds, the proof procedure returns
% true for $P$.
% If the bisimilarity check fails,
% we imprecisely return false for $P$ (without a counterexample).

% Finally, if $P_3$ neither
% relates two scalar values, nor relates two lifted expressions,
% we attempt to prove that {\tt LHS} of $P_3$ imply {\tt false}.
% If successfully disproven, we return false for $P$ with the counterexamples.
% Otherwise, we imprecisely return false for $P$ (without a counterexample).

% Please refer to {\tt Chapter \ThesisChapterAlgo{}} of the thesis for a
% detailed discussion on the algorithms introduced in this section along
% with their pseudo-code.