\section{Evaluation}
\label{sec:eval}

We have implemented \toolName{} on top of the
Counter tool \cite{oopsla20}.
We use four SMT solvers running in parallel for discharging
SMT proof obligations discharged by our proof discharge algorithm:
{\tt z3-4.8.7}, {\tt z3-4.8.14} \cite{z3},
{\tt Yices2-45e38fc} \cite{yices},
and {\tt cvc4-1.7} \cite{cvc4solver}.
An unroll factor of four is used to handle loop unrolling in the C implementation.
We use a default value of eight for
over- and under-approximation depths ($d_o$ and $d_u$).
The default value of
our unrolling parameter $k$ (used for categorization of proof obligations) is five.

The user provides a \SpecL{} program (specification), a C implementation,
and a file that contains the precondition and postcondition.
We use only four distinct ADTs (shown in \cref{tab:LiftingConsTable}) in our specification
programs written in \SpecL{}, one each for a string \inv{\small T1}, list \inv{\small T2},
tree \inv{\small T3}, and a two-dimensional
matrix \inv{\small T4}.
For example, the {\tt String} ADT is a sum-type formed by constructors
{\tt Invalid} (to
encode the well-formedness condition of a string, e.g., it should be non-null),
{\tt Nil} (representing an empty string) and {\tt Cons} (representing
a recursive construction formed through a product of a character and a string).

For each C implementation, an equivalence check requires the identification of
lifting constructors that relate C values to the ADT values in \SpecL{}.
The relations between a \SpecL{} value and a lifted value derived from C values (and current memory state)
may be required at the entry of both programs (i.e., in the precondition $Pre$),
in the middle of both programs (i.e., in the inferred invariants at intermediate product-CFG
nodes), and at the exit of both programs (i.e., in the postcondition $Post$).
$Pre$ and $Post$ are user-specified, but the inductive invariants are inferred
automatically by our algorithm.
 Our invariant inference algorithm derives
the shape of the lifting constructors from the user-specified $Pre$ and $Post$,
and uses these shapes in enumerating relational guesses at product-CFG nodes.
% The \recursiveRelations{} in the precondition,
% postcondition, and invariants may relate \SpecL{} ADT variables with the
% values lifted (through a lifting constructor) from C variables (and current
% memory state).
The same \SpecL{} program
is used for checking equivalence with multiple C implementations that may differ
in data layouts and algorithmic strategies.
The optimized algorithmic strategies involve
loop optimizations through unrolling and manual vectorization.

We consider implementations with diverse data layouts
for each \SpecL{} ADT (e.g., {\tt List, Matrix}).
This includes array, linked list for {\tt List} and
row and column major layouts for {\tt Matrix} to name a few.
% In a chunked linked list, a single list node (linked
% through a {\tt next} pointer)
% contains a small array (chunk) of values.
% We use a default chunk size of four for our
% benchmarks.
% If the chunk size is changed, one
% can simply re-run the equivalence checker
% (after updating $Pre$ and $Post$ accordingly)
% to confirm equivalence of the modified $C$ program against original $S$
% specification.
Next we consider each ADT in more detail. For each, we discuss
(a) its functions considered, (b) list of C data layouts along with
their lifting constructors and (c) different algorithmic strategies
encountered during evaluation.

% The required lifting constructor may be different for different data layouts.
% \Cref{tab:LiftingConsTable} shows the various lifting constructors used for validating
% the benchmarks we describe below. In this table,
% we use {\tt lnode(T)} to represent a linked list node
% which encapsulates a value of type {\tt T}.
% Similarly, {\tt clnode(T)} and {\tt tnode(T)} represent
% a chunked linked list node and a tree node respectively
% that encapsulate
% value(s) of type {\tt T}. {\tt u32} represents
% the 32-bit unsigned integer type.
% We use a ternary {\tt ite(c,x,y)} operator which
% returns {\tt x} if {\tt c} evaluates to true and {\tt y} otherwise.
% The syntax {\tt T[]} represents an array of type {\tt T}.
% {\tt T[r]} and {\tt T[c]} represent flattened
% arrays of type {\tt T}, flattened using row-major and column-major
% formats respectively.

\input{chapters/figures/figLiftingConsStr.tex}

\subsection{String} We wrote a single specification in \SpecL{} for each of the
following
common string library functions: {\tt strlen}, {\tt strchr}, {\tt strcmp}, {\tt strspn},
{\tt strcspn}, and {\tt strpbrk}.  For each specification
program, we took multiple C implementations of that program, drawn from popular
libraries like {\tt glibc} \cite{glibc}, {\tt klibc} \cite{klibc}, {\tt newlib} \cite{newlib},
{\tt openbsd} \cite{openbsdlibc}, {\tt uClibc} \cite{uclibc},
{\tt dietlibc} \cite{dietlibc}, {\tt musl} \cite{musl}, and {\tt netbsd} \cite{netbsd}.
Some of these libraries implement the same function in two ways: one that is optimized
for code size ({\tt small}) and another that is optimized for runtime ({\tt fast}).
All these library implementations use a {\em null character} terminated array to represent
a string, and the
corresponding lifting constructor is {\tt Cstr}$^{\tt char[]}_m$.

Further, we implemented
custom C implementations for some of these functions that used
linked-list
and {\em chunked linked list} data structures
to represent a string.
In a chunked linked list, a single list node (linked
through a {\tt next} pointer)
contains a small array (chunk) of values.
We use a default chunk size of four for our
benchmarks.
The corresponding lifting constructors are {\tt Cstr}$^{\tt lnode(char)}_m$
and {\tt Cstr}$^{\tt clnode(char)}_m$ respectively.
All three {\tt Cstr} lifting constructors are defined in \cref{tab:LiftingConsStr}.
{\tt Cstr}$^{\tt lnode(char)}_m$ requires a single
argument $p$ representing the $C$ pointer to the list node.
On the other hand, {\tt Cstr}$^{\tt clnode(char)}_m$ requires two arguments $p$
and $i$ where $p$ represents the pointer to the chunked linked list node
and $i$ represents the position of the initial character in the chunk.

We often label a lifting constructor based on its underlying data layout.
For example, {\tt Cstr}$^{\tt clnode(char)}_m$ represents a lifting constructor
with a chunked linked list of characters as its underlying data layout.
In general, {\tt T[]} represents an array of type T (e.g., {\tt char[]}).
{\tt lnode(T)} represents a  linked list node type which encapsulates a value of type {\tt T}.
Similarly, {\tt clnode(T)} and {\tt tnode(T)} represent a chunked linked list and a tree node
containing values of type {\tt T} represpectively.

\input{chapters/figures/figStrlenSpecAndC.tex}

\Cref{fig:strlenSpecAndC} shows the {\tt strlen} specification and two vastly
different $C$ implementations. \cref{fig:llStrlenCArrIR} is a generic implementation
using a null character terminated array to represent a string similar to a C-style string.
The second implementation in \cref{fig:llStrlenCClistIR} differs from \cref{fig:llStrlenCArrIR}
in the following: (a) it uses a chunked linked list data layout for string values
and (b) it uses optimized bit manipulation algorithm to identify whether one of the four
character bytes is zero (i.e. null) in a chunk at a time. \toolName{} is able to automatically
find and prove a bisimulation relation for both implementations against the unchanged specification.
\Cref{fig:StrlenProductCFGsAndInvs} shows the Product CFGs and Invariants for these two implementations.

\input{chapters/figures/figStrlenCfgsWithInvs.tex}

\subsection{List} We wrote a \SpecL{} program that creates a list and another \SpecL{}
program that traverses a list to compute the sum of all its elements. We use three different
data layouts for a list in C: character array ({\tt Clist}$_m^{\tt u32[]}$),
linked list ({\tt Clist}$_m^{\tt lnode(u32)}$), and
a chunked linked list ({\tt Clist}$_m^{\tt clnode(u32)}$).
\\ \\
\subsubsection*{Tree} We wrote a \SpecL{} program that sums all the nodes in a tree
through an inorder traversal. We use two different data layouts for a tree: 
(1) a flat array where a
complete binary tree is laid out in breadth-first search order ({\tt Ctree}$_m^{\tt u32[]}$),
and (2) a linked tree node with two pointers for the left and right children ({\tt Ctree}$_m^{\tt tnode(u32)}$).

\subsubsection*{Vector and Matrix} We wrote a \SpecL{} program to compute the dot-product
of two vectors, where a vector is of ADT type {\tt List} in \SpecL{}. Also, we wrote a
\SpecL{} program to compute the number of times a value appears in a 2D matrix. A
matrix is represented as an ADT that resembles a {\tt List} of {\tt List}s (\inv{\small T4} in \cref{tab:LiftingConsTable}).
The $C$ implementations for a {\tt Matrix2D} object include
a two-dimensional array ({\tt Cmat}$^{\tt u32[][]}_m$), a flattened row-major array ({\tt Cmat}$^{\tt u32[r]}_m$),
a flattened column-major array ({\tt Cmat}$^{\tt u32[c]}_m$), a linked list of 1D arrays ({\tt Cmat}$^{\tt lnode(u32[])}_m$),
a 1D array of linked lists ({\tt Cmat}$^{\tt lnode(u32)[]}_m$) and a 1D array of chunked linked list ({\tt Cmat}$^{\tt clnode(u32)[]}_m$)
data layouts.
%\footnote{Would it be possible to show figures for the following: strlen array + optimized chunked list IRs (CFGs can be ignored), 2 matrix data representations (atleast the C struct definitions if not the programs)}. ZZZ: Ok, let's put them in the appendix


\Cref{tab:results} lists all the various C implementations and the time it took
to compute equivalence with their \SpecL{} counterparts. For functions that
take two or more data structures as arguments, we show
results for different combinations of data layouts for each argument.
We also show the minimum under-approximation ($d_u$) and over-approximation ($d_o$) depths
at which the equivalence proof completed (keeping all other parameters to their
default values).

During the verification of {\tt strchr} and {\tt strpbrk} implementations,
we identified an interesting subtlety. Because {\tt strchr} and {\tt strpbrk}
return null if the character is
not present in the string, we additionally need to model the UB assumption that the zero
address does not belong to the null-terminated array representing the string. This
is modeled as a UB assumption $\neg${\tt ($s_S$ is SInvalid)} in the loop body that traverses the string
(so every substring needs to be valid) in $S$.
Because the lifting constructor
$\mathrm{Cstr^{T}_m(p:i32)}$ relates the {\tt SInvalid} constructor to {\tt p==0$_{\tt i32}$} (\cref{tab:LiftingConsTable}),
this ensures that the zero address cannot belong to the null-terminated array.