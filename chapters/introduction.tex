\section{Introduction}
\label{sec:intro}
The problem of equivalence checking between a functional specification and an
implementation written in a low level imperative language such as C
has been of major research interest
and has several important applications such as (a) program verification, where
the equivalence checker is used to verify that the C implementation
behaves according to the specification and (b) translation validation, where
the equivalence checker attempts to generate a proof of equivalence across
the transformations (and translations) performed by an optimizing compiler
and more.

The verification of a C implementation against its manually written
functional specification through manually-coded refinement proofs has been
performed extensively in the seL4 microkernel \cite{seL4}.
Frameworks for program equivalence proofs have been developed in interactive
theorem provers like Coq \cite{programEquivalenceInCoq} where correlations and invariants
are manually identified during proof codification.
On the other hand, programming languages like Dafny \cite{dafny} offer automated program
reasoning for imperative languages with abstract data types such as sets and arrays.
Such languages perform automatic compile-time checks for manually-specified
correctness predicates through SMT solvers.
Additionally, there exists significant prior work on translation validation
\cite{tvi,tristan_tv_eqsat11,stepp_eqsat_llvm11,eqsat,pec,zuck03,zuck05,heffter05,covac,c_to_verilog,kanade09,lopes16,tvoc_cav05,ddec,semalign,oopsla20,tv_oskernel,namjoshi13}
across low level programming languages such as C and assembly\footnote{XXX:llvm ir also?}.
In most of these applications, soundness in critial,
i.e., if the equivalence checker determines the programs to be equivalent, then the programs are indeed equivalent
and evidently has equivalent observable behaviour. On the other hand, a sound equivalence checker may be incomplete
and fail to prove equivalence of a program pair, even if they were equivalent.

We present \toolName{}, a {\em sound} algorithm to automatically (push-button) search
for a proof of equivalence between a functional specification and its
optimized C implementations. We will demonstrate how \toolName{} is capable of
proving equivalence of multiple equivalent C implementations with vastly
different (a) data layouts (e.g. array, linked list representations of a {\em list})
and (b) algorithmic strategies (e.g. alternate algorithms, optimizations) against
a {\em single} functional specification.
This opens the possibility of regression verification \cite{strichman_regressverify,felsing14},
where \toolName{} can be used to automate verification across
software updates that change memory layouts for data structures.

\subsection{A Motivating Example}
\label{sec:motivatingexample}
We restrict our attention to programs that construct, read, and write
to recursive data structures. In languages like C, pointer and array based
implementations of these data-structures are prone to safety and liveness bugs.
Similar recursive data structures are also available in safer functional languages like Haskell,
where algebraic data types (ADTs) \cite{hope} ensure several safety properties.
We define a minimal functional language, called \SpecL{}, that enables the safe
and succinct specification of programs manipulating and traversing recursive data structures.
\SpecL{} is equipped with ADTs as well as boolean (\type{bool}) and fixed-size bitvector (\type{i<N>}) types.

We motivate our approach by considering example \SpecL{} and C programs.
We list the major hurdles of our approach and give an informal discussion of our proposed solutions.
We finish by stating our primary contributions in \cref{sec:contribs}.

\input{chapters/figures/figMallocSpecAndC.tex}

\input{chapters/figures/figMallocSpecIRAndCIR.tex}

\Cref{fig:llAllocSpec,fig:llAllocC} show the construction of lists in \SpecL{} and C respectively.
The \type{List} ADT in the \SpecL{} program in defined at line {\tt A0} in \cref{fig:llAllocSpec}.
An empty \type{List} is represented by the constructor \cons{LNil}, where as a non-empty list uses
the \cons{LCons} constructor to combine its first value ({\tt val}\ctype{i32}) and
the remaining list ({\tt tail}\ctype{List}).
The inputs to a \SpecL{} procedure are its well-typed arguments, which may include recursive data structure values.
The inputs to a C procedure are its explicit arguments and the implicit state of program memory at procedure entry.
Similarly, the outputs of a C procedure include its explicit return value and the program memory at procedure exit.

The \SpecL{} procedure {\tt mk\_list}, defined at line {\tt A6} in \cref{fig:llAllocSpec}, accepts
a bitvector of size {\tt 32} ({\tt n}\ctype{i32}).
It returns a \type{List} ADT value representing a linked list containing
the values {\tt (n-1)}, {\tt (n-2)}, ..., {\tt 1}, {\tt 0} starting from the head (the first value).
On the other hand, the C procedure {\tt mk\_list}, defined at line {\tt B3} in \Cref{fig:llAllocC},
constructs a {\em pointer based} linked list identical to the \SpecL{} program in \cref{fig:llAllocSpec}.
Unlike \SpecL{}, the construction of the linked list requires explicit memory allocation and writes to
the memory in C.
We are interested in showing that the \SpecL{} and C {\tt mk\_list} procedures are `equivalent'
i.e. given equal {\tt n} inputs, they both construct linked lists that are `equal'.

first the unified representation
then lifting constructor and the idea of lifting
then bisimulation as the proof of equivalence
then invariants at internal nodes that may need lifting constructors

only introduce them briefly along with the mk\_list example.
keep it informal.

finish this section tomorrow for sure, then go into the next sections...
not much change is required in the later phases
mainly adding new figures and bits \& pieces to the proof discharge algorithm section
finish by 5th so I can at least send this portion to sir
then finish up the new section, and I am done...
hopefully enough time to carry out the merge...


We lower both \SpecL{} and C programs to a common intermediate representation (IR)
as shown in \cref{fig:llAllocSpecIR,fig:llAllocCIR}.
For the \SpecL{} program in \cref{fig:llAllocSpec},
the tail-recursive function {\tt mk\_list\_impl} is converted to a loop and
inlined in the top-level function {\tt mk\_list}.
For the C program in \cref{fig:llAllocC},
the sizes and memory layouts of both scalar (e.g., \type{unsigned})
and compound (e.g., \type{struct lnode}) types are concretized in the IR.

\input{chapters/figures/figMallocSpecCFGAndCCFG.tex}

\Cref{fig:llAllocSpecIRCFG,fig:llAllocCCFG} show the Control-Flow Graph (CFG) representation
of the \SpecL{} and C IR programs in \cref{fig:llAllocSpecIR,fig:llAllocCIR} respectively.
Each node represent a PC location of its corresponding program, and each edge represent
conditional transition between PCs through instruction execution.
For brevity, we often represent a sequence of instructions with a single edge, e.g.,
in \cref{fig:llAllocCCFG}, the edge \cpath{5,3} represents the path \cpath{5,6,7,8,3}.

\input{chapters/figures/figMallocProductCFG.tex}

We construct a {\em bisimulation relation} to identify equivalence between the two programs.
A bisimulation relation correlates the transitions of \SpecL{} and C programs in lockstep, such that the
lockstep execution ensures identical observable behavior.
A bisimulation relation between two programs can be represented using a {\em product program}
\cite{covac} and the CFG representation of a product program is called a {\em product-CFG}.
\Cref{fig:llAllocProductCFG} shows a product-CFG, that encodes the lockstep execution
(bisimulation relation) between the CFGs in \cref{fig:llAllocSpecIRCFG,fig:llAllocCCFG}.

\input{chapters/figures/figMallocInvs.tex}

At each node of the product-CFG, invariants relate the states of the \SpecL{} and C program respectively.
\Cref{tab:llproductInv} lists invariants for the product-CFG in \cref{fig:llAllocProductCFG}.
At the start node \scpc{0}{0} of the product-CFG, the precondition $Pre$ (labeled \circled{\small P})
ensures equality of input arguments \sv{n} and \cv{n} at the programs' entry.
Inductive invariants (labeled \circled{\small I}) are inferred at
each intermediate product-CFG node (e.g., \scpc{3}{3}) relating both programs' states.
For example, at node \scpc{3}{5}, \circled{\small I6} $\sv{i} = \cv{i}$ is an inductive invariant.

In \cref{tab:llproductInv}, the invariant \circled{\small I4} $\sv{l} \indEq{} \lifted{list}{\mem{}}{lnode}{\cv{l}}$
is an example of a \recursiveRelation{} and represents equality between the \SpecL{} \type{List} variable \sv{l}
and the \type{{List}} represented by chasing the \type{lnode} pointers starting at \cv{l}.
\lift{list}{\mem{}}{lnode} is an example of a {\em lifting constructor} that `lifts' a C pointer value
(pointing to an object of type \type{struct lnode}) and the C memory state \mem{}
to a \SpecL{} \type{List} value, and is defined as follows:
\begin{equation}
\label{eqn:clist}
\begin{split}
U_C:\ &\lifted{list}{\mem{}}{lnode}{p \ctype{i32}} = \sumIf{p=0} \ \sumThen{\cons{LNil}} \\ & \qquad\qquad\ \ \ \sumElse{\cons{LCons}(\structPointer{p}{\mem{}}{lnode}{val}, \lifted{list}{\mem{}}{lnode}{\structPointer{p}{\mem{}}{lnode}{next}})}
\end{split}
\end{equation}

Product-CFG invariants involving \recursiveRelations{} (e.g., \circled{\small I4}) allow
us to express equality between native \SpecL{} values with the C program state.
Assuming that the precondition $Pre$ (\circled{\small P}) holds at the entry node \scpc{0}{0},
a bisimulation check involves checking that the inductive invariants hold too,
and consequently the postcondition $Post$ (\circled{\small E}) holds at the exit node \scpc{E}{E}.
Checking whether an invariant holds results in proof queries.
These proof obligations are expressed as relational Hoare triples \cite{relationalHoareLogic,hoareTriple}
and discharged through a proof discharge algorithm i.e. a solver.
We give a more formal exposition of the concepts introduced in this summary in the coming chapters.

\subsection{Our Contributions}
\label{sec:contribs}
As previously summarized in \cref{sec:summary}, showing equivalence of a \SpecL{} and a C program
through a bisimulation proof requires three major procedures:
\circled{\small 1} An algorithm for construction of a product-CFG by correlating program executions
across the \SpecL{} and C programs respectively.
\circled{\small 2} An algorithm for identification of inductive invariants at intermediate correlated PCs.
\circled{\small 3} An algorithm for solving proof obligations containing \recursiveRelations{}.
Our major contributions are as follows:

\begin{itemize}
\item Proof Discharge Algorithm: Solving proof obligations (\circled{\small 3})
involving \recursiveRelations{} is rather interesting and forms our primary contribution.
We describe a {\em sound} proof discharge algorithm capable of tackling proof obligations involving
\recursiveRelations{} using off-the-shelf SMT solvers. Our proof discharge algorithm is also capable of
reconstruction of counterexamples for the original proof query from models returned by the individual SMT queries.
These counterexamples are the backbone of counterexample-guided algorithms for
\circled{\small 1} and \circled{\small 2} steps. As part of our proof discharge procedure,
we reformulate equality of values (i.e. \recursiveRelations{}) as equivalence of their corresponding programs
and discharge these proof queries using a nested (albeit much simpler) bisimulation check.

\item Spec-to-C Automatic Equivalence Checker Tool: Our second contribution is \toolName{}, an equivalence checker tool
capable of proving equivalence between a \SpecL{} and a C program automatically.
\toolName{} is based on
the Counter tool\cite{oopsla20} and uses modified versions of (a) counterexample-guided correlation algorithm for
incremental construction of a product-CFG and (b) counterexample-guided invariant inference algorithm
for inference of inductive invariants at correlated PCs in the (partially constructed) product-CFG.
\toolName{} discharges required verification conditions (i.e. proof obligations) using our Proof Discharge Algorithm.
\Cref{fig:diagram} gives an overview of the complete algorithm.
\end{itemize}

\input{chapters/figures/figDIAGRAM.tex}