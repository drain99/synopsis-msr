\section{Introduction}
\label{sec:intro}
The problem of equivalence checking between a functional specification and an
implementation written in a low level imperative language such as C
has been of major research interest
and has several important applications such as (a) program verification, where
the equivalence checker is used to verify that the C implementation
behaves according to the specification and (b) translation validation, where
the equivalence checker attempts to generate a proof of equivalence across
the transformations (and translations) performed by an optimizing compiler
and more.

The verification of a C implementation against its manually written
functional specification through manually-coded refinement proofs has been
performed extensively in the seL4 microkernel \cite{seL4}.
Frameworks for program equivalence proofs have been developed in interactive
theorem provers like Coq \cite{programEquivalenceInCoq} where correlations and invariants
are manually identified during proof codification.
On the other hand, programming languages like Dafny \cite{dafny} offer automated program
reasoning for imperative languages with abstract data types such as sets and arrays.
Such languages perform automatic compile-time checks for manually-specified
correctness predicates through SMT solvers.
Additionally, there exists significant prior work on translation validation
\cite{tvi,tristan_tv_eqsat11,stepp_eqsat_llvm11,eqsat,pec,zuck03,zuck05,heffter05,covac,c_to_verilog,kanade09,lopes16,tvoc_cav05,ddec,semalign,oopsla20,tv_oskernel,namjoshi13}
across low level programming languages such as C and assembly.
In most of these applications, soundness in critial,
i.e., if the equivalence checker determines the programs to be equivalent, then the programs are indeed equivalent
and evidently has equivalent observable behaviour. On the other hand, a sound equivalence checker may be incomplete
and fail to prove the programs to be equivalent, even if they were equivalent.

\subsection{Problem Setting}
We restrict our attention to programs that construct, read, and write
to recursive data structures. In languages like C, pointer and array based
implementations of these data-structures are prone to safety and liveness bugs.
Similar recursive data structures are also available in safer functional languages like Haskell,
where algebraic data types (ADTs) \cite{hope} ensure several safety properties.
We define a minimal functional language, called \SpecL{}, that enables the safe
and succinct specification of programs manipulating and traversing recursive data structures.
\SpecL{} is equipped with ADTs as well as boolean and bitvector (\type{i<N>}) types.

We present \toolName{}, a {\em sound} algorithm to automatically (push-button) search
for a proof of equivalence between a functional specification (written in \SpecL{}) and its
optimized C implementation. We will demonstrate how \toolName{} is capable of
proving equivalence of multiple equivalent C implementations with vastly
different (a) data layouts (e.g. array, linked list representations of a {\em list})
and (b) algorithmic strategies (e.g. alternate algorithms, optimizations) against
a {\em single} functional specification.
This opens the possibility of regression verification \cite{strichman_regressverify,felsing14},
where \toolName{} can be used to automate verification across
software updates that change memory layouts for data structures.
Next, we shortly describe our approach with examples and list the major subgoals.
We finish this section by listing our primary contributions.

\subsection{Our Contributions}

% finish our this section, then link directly to the contributions of synopsis finishing this section
% let's put mk_list and sum_list programs in both Spec and C here 

% next section goes into the IR, show the IRs of all 4 programs!!
% then the CFG representation of the IR
% then introduce bisimulation and product-CFG
% also introduce the invariants table

% Recursive data structures like lists, strings, and trees
% are the building blocks of many algorithms and
% software systems. In languages
% like C, pointer and array based
% implementations of these data-structures
% are prone to safety and liveness bugs.
% Similar recursive data structures
% are also available in safer functional languages
% like Haskell, where
% algebraic data types (ADTs) \cite{hope} ensure
% several safety properties.

% \input{chapters/figures/figMallocSpecAndC.tex}

% The programs
% in \cref{fig:llAllocSpec,fig:llAllocC}
% construct lists in a functional language and in C respectively.
% %While the C implementation is likely more efficient,
% %the functional language program is
% %safer and more succinct.
% %For example,
% %the C implementation may be prone to bugs that
% %may yield out-of-bounds
% %memory accesses at runtime (safety bug), or inadvertently create
% %a cycle in the list (liveness bug).
% In prior work on formally-verified systems (e.g., seL4 \cite{seL4}),
% researchers have employed interactive proof assistants
% to prove that a
% C implementation is observably
% equivalent to
% a higher-level
% functional implementation.
% % Such equivalence
% %proofs ensure functional equality of the observable
% %behaviour of the two
% %programs written in different syntaxes, and
% %effectively rule out a large category of safety and
% %liveness bugs.  For example, if a list
% %datatype in the functional
% %language does not allow the creation of cycles, then
% %by proving equivalence with a pointer-based C implementation, we
% %rule out the potential
% %creation of a cycle in the latter.  Similarly,
% %an equivalence proof ensures the absence of stray memory accesses
% %in the C implementation. Further,
% %observable behaviour equivalence
% %of the two programs
% %significantly increases confidence in the functional correctness of
% %the C implementation.
% Unfortunately, this method
% of manually codifying equivalence proofs
% through an interactive theorem
% prover requires expertise and is laborious.
% %Moreover, such manually-codified proofs are usually not amenable to
% %reuse: separate
% %proofs are often required for each different implementation of
% %a data structure.
% %The proof-effort in
% %developing a formally-verified program
% %can be 10x
% %more than the corresponding coding-effort \cite{fscq,rayWangArticleOnFormalVerification17}.
% %For these
% %reasons, even though the development of formally-verified
% %systems is compelling, its pace of
% %adoption has been slow.

% We present \toolName{}, an algorithm to automatically
% search for a proof of equivalence between a functional specification
% of a recursive data-structure program
% and its
% optimized C implementation.
% To support
% this, we define a minimal functional language, called \SpecL{}, that enables the
% safe and succinct specification
% of programs manipulating and traversing recursive data structures.
% Our proof-search algorithm automatically (push-button)
% searches for a bisimulation relation
% between data-structure manipulation programs
% written in \SpecL{} and C.
% The large semantic gap between
% the two syntaxes make such automatic
% proofs particularly interesting: for the same \SpecL{} specification,
% there exist multiple
% C implementations that may differ in their memory layout and
% iteration logic; yet, \toolName{} can compare equivalence for all such
% program pairs automatically.

% \input{chapters/figures/figMallocSpecIRAndCIR.tex}

% Such equivalence proofs require the
% inference of relations between data-structure values
% at correlated intermediate program points of both programs.
% For example, if we correlate PC {\tt S3} of the \SpecL{}
% IR program in \cref{fig:llAllocSpecIR}
% with PC {\tt C3} of the C IR program in \cref{fig:llAllocCIR}, we
% need to infer
% that the contents of the entire linked list starting at
% variable {\tt l$_C$} in the C program are equal to
% the contents of the {\tt List} value {\tt l$_S$} in the \SpecL{} program.
% (Throughout the paper, we use subscripts $S$ and $C$ to represent values
% of the \SpecL{} and C programs respectively).
% We call such relations that relate
% recursive data structure values, {\em \recursiveRelations{}}.
% The automatic
% inference of invariants
% with \recursiveRelations{}
% relies on the discharge of proof obligations
% that involve equality of arbitrarily deep
% data structures.
% %We
% %develop \recursiveInvariant{} shapes with clear
% %and intuitive semantics that are also
% %amenable to automated reasoning of equivalence across
% %two different representations.
% %To derive aliasing constraints required for checking
% %these invariant shapes, we leverage the semantics of
% %the C language and associated allocation-related
% %library functions like {\tt malloc()}.
% {\em Our primary contribution is a
% proof discharge algorithm that
% uses an off-the-shelf SMT
% solver to tackle proof obligations involving \recursiveRelations{}
% in the context of an equivalence check}.

% Our algorithm leverages prior work on automatic counterexample-guided
% search for a
% bisimulation relation \cite{oopsla20}.
% At every step of this counterexample-guided search for
% a bisimulation relation,
% inductive invariants and correlations are proposed which need to
% be checked using off-the-shelf SMT solvers.
% Thus, a proof obligation, that may potentially involve a
% \recursiveRelation{}, needs to be converted to a form that is
% amenable for reasoning through an SMT solver.
% Further, if an SMT proof query is determined to be {\em not provable},
% we expect a counterexample; this counterexample represents
% a potential concrete machine state that may
% occur in the program (based on our invariant
% reasoning).
% These counterexamples help in faster convergence
% of the invariant inference and correlation algorithms
% during the automatic construction of a bisimulation relation.
% This requires the reconstruction of a machine state which may include
% recursive ADT values from counterexamples returned by the SMT solver.
% These procedures to convert a proof obligation involving a \recursiveRelation{}
% to a sequence of SMT solver queries and the conversion back from the SMT-generated
% counterexamples to a machine state possibly containing ADT values, are part
% of our proof discharge algorithm.

% We have manually
% developed a small
% number of succinct specifications of data-structure
% programs in \SpecL{}
% involving ADT-based
% lists, strings, trees, and two-dimensional matrices.
% Using these,
% we automatically verify
% equivalent programs in
% popular C libraries with
% strings and common functions operating
% on lists, trees, matrices.
% A diverse set of data layouts are
% considered for each such data structure.
% For example, a list may be implemented
% using a flat array, a linked list or even
% a chunked linked list (each node contains a constant-sized chunk).
% On the other hand, a matrix might be laid out in a 2-dimensional array,
% a row major array, a column major array or an array of linked lists etc.
% For one specification program in \SpecL{}, multiple
% different C
% implementations are verified.
% %In the paper, we
% %also discuss
% %some implementation subtleties of
% %these programs revealed by these
% %verification efforts that usually
% %go unnoticed.
