\section{Related Work and Conclusion}
\label{sec:relwork}
The verification of a C implementation against
its functional specification through manually-coded
refinement proofs has been performed
extensively in the seL4 microkernel \cite{seL4}.
While the size of programs
considered in our work is much smaller,
we hope the ideas in \toolName{} will help
automate the proofs for such systems to some degree.

There exists significant prior work on automatic
equivalence checking in the context of
translation
validation \cite{tvi,tristan_tv_eqsat11,stepp_eqsat_llvm11,eqsat,pec,zuck03,zuck05,heffter05,covac,c_to_verilog,kanade09,lopes16,tvoc_cav05,ddec,semalign,oopsla20,tv_oskernel,namjoshi13}.
\toolName{} is perhaps most applicable in the context of
regression verification \cite{strichman_regressverify,felsing14}, where
the specification to verify the absence of regressions may be written
in a higher-level functional syntax. Using
a higher-level functional syntax for the specification
allows automatic regression verification across software updates
that change
data layouts and algorithms.

Frameworks for program equivalence proofs have been developed
in interactive theorem provers like Coq \cite{programEquivalenceInCoq}
where correlations and invariants are identified manually during
proof codification.
Programming languages like Dafny \cite{dafny} offer automated program
reasoning facilities for imperative languages with
algebraic data types. Such languages perform automatic
compile-time checks
for manually-specified safety
and liveness predicates. Prior work on push-button
verification of specific
systems \cite{fscq,hyperkernel,serval,verifiedBPF}
involves a combination
of careful system design and
automatic verification tools like SMT solvers.
Constrained Horn Clause (CHC) Solvers \cite{CHCeq}
encode verification
conditions of programs containing loops and recursion,
and raise the level of abstraction for automatic proofs.
Compared to prior work, \toolName{} further raises the level
of abstraction for automatic verification from
SMT queries and CHC queries to automatic discharge of
proof obligations involving \recursiveRelations{}.
Our equivalence checking tool based on
our proof discharge algorithm requires the user
to only specify the precondition and
postcondition --- all
correlations and invariants involving \recursiveRelations{}
are identified automatically.

A key idea in \toolName{}
is the conversion of proof
obligations involving \recursiveRelations{} to
bisimulation checks. Thus, \toolName{}
performs {\em nested}
bisimulation checks as part
of a ``higher-level''
bisimulation search. This approach of
identifying \recursiveRelations{} as invariants and using
bisimulation to discharge the associated
proof obligations may have applications
beyond equivalence checking.