\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

We describe an algorithm capable of checking
equivalence of two programs that manipulate recursive
data structures such as linked lists, strings, trees
and matrices. The first program, called specification,
is written in a succinct and safe functional language
with algebraic data types (ADT).
The second program, called implementation,
is written in C using arrays and pointers.
Our algorithm, based on prior work on
counterexample guided equivalence checking,
automatically searches for a sound equivalence proof
between the two programs.

\noindent We formulate an algorithm for discharging
proof obligations containing relations
between recursive data structure values across
the two diverse syntaxes, which forms our first contribution.
Our proof discharge algorithm is capable
of generating falsifying counterexamples in case of
a proof failure.
These counterexamples help guide the search for a sound equivalence proof
and aid in inference of invariants.
As part of our proof discharge algorithm,
we formulate a program representation of values.
This allows us to reformulate proof obligations
due to the top-level equivalence check
into smaller nested equivalence checks.
Based on this algorithm,
we implement an automatic (push-button) equivalence checker tool named \toolName{},
which forms our second contribution.

\noindent \toolName{} is evaluated on
implementations of common string library
functions taken from popular C library implementations,
as well as
implementations of common list, tree and matrix programs.
These implementations differ in data layout
of recursive data structures as well as
algorithmic strategies.
We demonstrate that \toolName{} is able to establish equivalence
between a single specification and its diverse C implementations.

\textbf{Keywords:} \textit{Equivalence checking; Bisimulation; Recursive Data Structures; Algebraic Data Types;}
