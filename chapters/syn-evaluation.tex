\section{Evaluation}
\label{sec:syn-eval}

We have implemented \toolName{} on top of the
Counter tool \cite{oopsla20}.
We use four SMT solvers running in parallel for discharging
SMT proof obligations discharged by our proof discharge algorithm:
{\tt z3-4.8.7}, {\tt z3-4.8.14} \cite{z3},
{\tt Yices2-45e38fc} \cite{yices},
and {\tt cvc4-1.7} \cite{cvc4solver}.
An unroll factor of four is used to handle loop unrolling in the C implementation.
We use a default value of eight for
over- and under-approximation depths ($d_o$ and $d_u$).
The default value of
our unrolling parameter $k$ (used for categorization of proof obligations) is five.

\toolName{} requires the user to provide a \SpecL{} program (specification), a C implementation,
and a file that contains the precondition and postcondition. All inductive invariants
at intermediate nodes in the product-CFG are inferred automatically.
We consider programs involving four distinct ADTs, namely,
\inv{\small T1} String, \inv{\small T2} List, \inv{\small T3} Tree
and \inv{\small T4} Matrix.
% For example, the {\tt String} ADT is a sum-type formed by constructors
% {\tt Invalid} (to
% encode the well-formedness condition of a string, e.g., it should be non-null),
% {\tt Nil} (representing an empty string) and {\tt Cons} (representing
% a recursive construction formed through a product of a character byte and a string).

% For each C implementation, an equivalence check requires the identification of
% lifting constructors that relate C values to the ADT values in \SpecL{}.
% The relations between a \SpecL{} value and a lifted value derived from C values (and current memory state)
% may be required at the entry of both programs (i.e., in the precondition $Pre$),
% in the middle of both programs (i.e., in the inferred invariants at intermediate product-CFG
% nodes), and at the exit of both programs (i.e., in the postcondition $Post$).
% $Pre$ and $Post$ are user-specified, but the inductive invariants are inferred
% automatically by our algorithm.
% Our invariant inference algorithm derives
% the shape of the lifting constructors from the user-specified $Pre$ and $Post$,
% and uses these shapes in enumerating relational guesses at product-CFG nodes.
% The \recursiveRelations{} in the precondition,
% postcondition, and invariants may relate \SpecL{} ADT variables with the
% values lifted (through a lifting constructor) from C variables (and current
% memory state).

\input{chapters/figures/figLiftingConsStr.tex}

\subsection{Experiments}
For each \SpecL{} program specification, we consider multiple
C implementations that differ in the (a) layout and representation of ADTs, and
(b) algorithmic strategies. For example, a {\tt Matrix}, in C, may be laid out
in a two-dimensional array, a one-dimensional array using row or column major
layouts etc. On the other hand, an optimized implementation may choose manual vectorization
of an inner-most loop. Next, we consider each ADT in more detail. For each,
we discuss (b) its corresponding programs, (b) list of C layouts and their lifting
constructors, and (c) different algorithmic strategies.

% The required lifting constructor may be different for different data layouts.
% \Cref{tab:LiftingConsTable} shows the various lifting constructors used for validating
% the benchmarks we describe below. In this table,
% we use {\tt lnode(T)} to represent a linked list node
% which encapsulates a value of type {\tt T}.
% Similarly, {\tt clnode(T)} and {\tt tnode(T)} represent
% a chunked linked list node and a tree node respectively
% that encapsulate
% value(s) of type {\tt T}. {\tt u32} represents
% the 32-bit unsigned integer type.
% We use a ternary {\tt ite(c,x,y)} operator which
% returns {\tt x} if {\tt c} evaluates to true and {\tt y} otherwise.
% The syntax {\tt T[]} represents an array of type {\tt T}.
% {\tt T[r]} and {\tt T[c]} represent flattened
% arrays of type {\tt T}, flattened using row-major and column-major
% formats respectively.

\input{chapters/figures/figStrlenSpecAndC.tex}

\subsubsection{String} We wrote a single specification in \SpecL{} for each of the
following
common string library functions: {\tt strlen}, {\tt strchr}, {\tt strcmp}, {\tt strspn},
{\tt strcspn}, and {\tt strpbrk}.  For each specification
program, we took multiple C implementations of that program, drawn from popular
libraries like {\tt glibc} \cite{glibc}, {\tt klibc} \cite{klibc}, {\tt newlib} \cite{newlib},
{\tt openbsd} \cite{openbsdlibc}, {\tt uClibc} \cite{uclibc},
{\tt dietlibc} \cite{dietlibc}, {\tt musl} \cite{musl}, and {\tt netbsd} \cite{netbsd}.
Some of these libraries implement the same function in two ways: one that is optimized
for code size (subscripted with {\tt s}) and another that is optimized for runtime (subscripted with {\tt f}).
All these library implementations use a {\em null character} terminated array to represent
a string, and the
corresponding lifting constructor is {\tt Cstr}$^{\tt u8[]}_m$.
{\tt u<N>} represents the N-bit unsigned integer in C.
For example, {\tt u8} represents {\tt unsigned char} type.

Further, we implemented
custom C programs for all of these functions that used
linked list
and {\em chunked linked list} data structures
to represent a string.
In a chunked linked list, a single list node (linked
through a {\tt next} pointer)
contains a small array (chunk) of values.
We use a default chunk size of four for our
benchmarks.
The corresponding lifting constructors are {\tt Cstr}$^{\tt lnode(u8)}_m$
and {\tt Cstr}$^{\tt clnode(u8)}_m$ respectively.
The {\tt Cstr} lifting constructors are defined in \cref{tab:LiftingConsStr}.
{\tt Cstr}$^{\tt lnode(u8)}_m$ requires a single
argument $p$ representing the pointer to the list node.
On the other hand, {\tt Cstr}$^{\tt clnode(u8)}_m$ requires two arguments $p$
and $i$ where $p$ represents the pointer to the chunked linked list node
and $i$ represents the position of the initial character in the chunk.

Usually, we name a lifting constructor based on its underlying data layout.
For example, {\tt Cstr}$^{\tt clnode(u8)}_m$ represents a lifting constructor
with a chunked linked list of characters as its underlying data layout.
In general, we use the following naming convension for different data layouts.
{\tt T[]} represents an array of type T (e.g., {\tt u8[]}).
{\tt lnode(T)} represents a  linked list node type which encapsulates a value of type {\tt T}.
Similarly, {\tt clnode(T)} and {\tt tnode(T)} represent a chunked linked list and a tree node
containing values of type {\tt T} respectively.

\input{chapters/figures/figStrlenCfgsWithInvs.tex}

\Cref{fig:strlenSpecAndC} shows the {\tt strlen} specification and two vastly
different $C$ implementations. \cref{fig:llStrlenCArrIR} is a generic implementation
using a null character terminated array to represent a string similar to a C-style string.
The second implementation in \cref{fig:llStrlenCClistIR} differs from \cref{fig:llStrlenCArrIR}
in the following: (a) it uses a chunked linked list data layout for string values
and (b) it uses specialized bit manipulations to identify a zero character in a chunk at a time.
\toolName{} is able to automatically find a bisimulation implying equivalence
for both implementations against the unaltered specification.
\Cref{fig:StrlenProductCFGsAndInvs} shows the product-CFG and invariants for each implementation.

\input{chapters/figures/figLiftingConsList.tex}
\vspace{-10px}
\subsubsection{List} We wrote a \SpecL{} program specification that creates a list, a
program that traverses a list to compute the sum of its elements and a program
that computes the dot product of two lists. We use three different
data layouts for a list in C: character array ({\tt Clist}$_m^{\tt u32[]}$),
linked list ({\tt Clist}$_m^{\tt lnode(u32)}$), and
a chunked linked list ({\tt Clist}$_m^{\tt clnode(u32)}$).
The lifting constructors are shown in \cref{tab:LiftingConsList}.
Although similar to the String lifting constructors, these lifting
constructors differ widely in their data encodings. For example,
{\tt Clist}$_m^{\tt u32[]}$ represents a list value constructed
from a C array of size $n$ pointed to by $p$. The list becomes empty
when we are at the end of the array. {\tt Clist}$_m^{\tt lnode(u32)}$
and {\tt Clist}$_m^{\tt clnode(u32)}$, on the other hand, encodes empty
lists using {\em null pointers}. These encodings are in contrast to the
String lifting constructors, all of which uses {\em null character} to
encode the empty string.

\input{chapters/figures/figLiftingConsTree.tex}
\vspace{-10px}
\subsubsection{Tree} We wrote a \SpecL{} program that sums all the nodes in a tree
through an inorder traversal using recursion. We use two different data layouts for a tree: 
(1) a flat array where a
complete binary tree is laid out in breadth-first search order commonly used for heaps ({\tt Ctree}$_m^{\tt u32[]}$),
and (2) a linked tree node with two pointers for the left and right children ({\tt Ctree}$_m^{\tt tnode(u32)}$).
Both \SpecL{} and C programs contain non-tail recursive procedure calls for left and right children.

\input{chapters/figures/figLiftingConsMatrix.tex}
\vspace{-10px}
\subsubsection{Matrix} We wrote a
\SpecL{} program to count the frequency of a value appearing in a 2D matrix.
A matrix is represented as an ADT that resembles a {\tt List} of {\tt List}s (\inv{\small T4} in \cref{tab:LiftingConsMatrix}).
The $C$ implementations for a {\tt Matrix} object include
a two-dimensional array ({\tt Cmat}$^{\tt u32[][]}_m$), a flattened row-major array ({\tt Cmat}$^{\tt u32[r]}_m$),
a flattened column-major array ({\tt Cmat}$^{\tt u32[c]}_m$), a linked list of 1D arrays ({\tt Cmat}$^{\tt lnode(u32[])}_m$),
a 1D array of linked lists ({\tt Cmat}$^{\tt lnode(u32)[]}_m$) and a 1D array of chunked linked list ({\tt Cmat}$^{\tt clnode(u32)[]}_m$)
data layouts. Note that both {\tt T[r]} and {\tt T[c]} represent an array of type {\tt T}. The {\em r} and {\em c} simply
emphasizes that these flat arrays are used to represent 2-dimensional matrices in row-major and column-major encodings
respectively. We also introduce two auxiliary lifting constructors, {\tt Clist}$_m^{\tt u32[r]}$ and {\tt Clist}$_m^{\tt u32[r]}$
for lifting each row of matrices lifted using the corresponding {\tt Cmat}$_m^{\tt u32[r]}$ and {\tt Cmat}$_m^{\tt u32[r]}$ Matrix lifting
constructors. These constructors are listed in \cref{tab:LiftingConsMatrix}.

\input{chapters/figures/figEvalTable.tex}
\vspace{-12px}
\subsection{Results}
\vspace{-10px}
\Cref{tab:results} lists the various C implementations and the time it took
to compute equivalence with their \SpecL{} counterparts. For functions that
take two or more data structures as arguments, we show
results for different combinations of data layouts for each argument.
We also show the minimum under-approximation ($d_u$) and over-approximation ($d_o$) depths
at which the equivalence proof completed (keeping all other parameters to their
default values).

% During the verification of {\tt strchr} and {\tt strpbrk} implementations,
% we identified an interesting subtlety. Since {\tt strchr} and {\tt strpbrk}
% return null pointers to signify absence of the required character(s) in the input string,
% we additionally need to model the UB assumption that the zero
% address does not belong to the null-terminated array representing the string. This
% is modeled as a UB assumption $\neg${\tt ($s_S$ is SInvalid)} in the loop body that traverses the string
% using the {\tt assuming-do} statement discussed in \cref{sec:speclang}.
% This constraints the inputs to only valid string values in $S$ (that do not contain the {\tt SInvalid} constructor)
% during equivalence check.
% The string lifting constructors {\tt Cstr}$_m^{\tt T}\mathrm{(p:i32,...)}$
% relate the {\tt SInvalid} constructor to the condition {\tt (p == 0$_{\tt i32}$)} (as defined in \cref{tab:LiftingConsList}).
% This ensures that the zero address cannot belong to the null-terminated array.
% Furthermore, these lifting constructors are used to assert equality of lists in the $S$ and $C$ programs as
% part of the precondition $Pre$.
% This constrains the inputs of $C$ also to valid strings only (that do not contain a character at the null address)
% during equivalence check due to the $(S\ \  \mathrm{\tt def})$ assumption.
% This is an example where $(S\ \  \mathrm{\tt def})$
% and $Pre$ are used in combination to constrain the inputs of $S$ and $C$ to only well-formed values.
