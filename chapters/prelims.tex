\section{Preliminaries}
\label{sec:prelims}

\subsection{The \SpecL{} Language}
\label{sec:speclang}
We start with an introduction to the \SpecL{} language.
\SpecL{} supports recursive algebraic data types (ADT) \footnote{TODO:cite pls} similar to the ones available in most functional languages (e.g. Haskell\footnote{TODO:cite pls}).
\SpecL{} does not support parametric types but does allow ADTs which are mutually recursive.
Additionally, \SpecL{} is equipped with the following {\em scalar} types: \type{unit}, \type{bool} (boolean) and \type{i<N>} (bitvector of size {\tt N}).
ADTs can be thought of as `sum of product' types where each {\em data constructor} represents a variant
and the arguments to each data constructor represents its {\em fields}.
For example, the \type{List} type (defined at \apc{0} in \cref{fig:llAllocSpec}) has two variants \cons{LNil} and \cons{LCons}.
\cons{LNil} has no fields while \cons{LCons} has two fields \field{val} and \field{tail} of types \type{i32} and \type{List} respectively.
Additionally, \SpecL{} follows {\em equirecursive} typing rules \footnote{TODO:cite pls} i.e.
a \type{List} value $l$ and $\cons{LCons}(1_\type{i32}, l)$ have {\em equal} types.
Later in \cref{sec:valuegraph}, we give a more formal definition of ADTs with their graphical representation.
The language also borrows its expression grammar heavily from functional languages.
This includes the constructs: {\tt let-in}, {\tt if-then-else}, {\tt match} and function application expressions.
Pattern matching (i.e. deconstruction) of ADT values is archieved through {\tt match}.
Unlike functional languages, \SpecL{} only supports first order functions.
Also, \SpecL{} does not support partial function application.
Hence, we constrain our attention to C programs containing only first order functions.
\SpecL{} is equipped with a special {\tt assuming-do} construct for explicitly providing assertions.
\SpecL{} also provides intrinsic scalar operators for expressing computation in C succintly yet explicitly.
This includes logical operators (e.g., {\tt and}), bitvector arithmatic operators (e.g., {\tt bvadd(+)}) and
relational operators for comparing bitvectors interpreted as unsigned or signed integers (e.g., {\tt $\leq_{\tt u,s}$}).
The equality operator ($=$) is only supported for scalar types.

\input{chapters/figures/figSpecGrammar.tex}

\Cref{fig:specgrammar} shows the simplified expression grammar for \SpecL{} language.
\nonTerm{data-cons} represents a ADT data constructor.
The `\nonTerm{expr} {\tt is} \nonTerm{data-cons}' construct returns a \type{bool} and is used to test whether the top-level constructor
of the ADT value \nonTerm{expr} is \nonTerm{data-cons}.
\nonTerm{scalar-op} includes the logical, arithmatic and relational operators supported by \SpecL{}.

\subsection{Equivalence Definition}
\label{sec:eqdef}
Given (1) a \SpecL{} function specification \sprog{}, (2) a C implementation \cprog{},
(3) a precondition \pre{} that relates the initial inputs \sv{Input} and \cv{Input} to
\sprog{} and \cprog{} respectively, and (4) a postcondition \post{} that relates the final outputs
\sv{Output} and \cv{Output} of \sprog{} and \cprog{} respectively\footnote{\cv{Input} and \cv{Output}
include the initial and final memory state of \cprog{} respectively.}:
\sprog{} and \cprog{} are {\em equivalent} if for all possible inputs \sv{Input} and \cv{Input} such that
$\pre{}(\sv{Input},\cv{Input})$ holds,
\sprog{}'s execution is well-defined on \sv{Input}, {\em and}
\cprog{}'s memory allocation requests during its execution on \cv{Input} are successful,
then both programs \sprog{} and \cprog{} produce outputs such that $\post{}(\sv{Output},\cv{Output})$ holds.
$$
\pre{}(\sv{Input},\cv{Input}) \land \sdef{} \land \cfits{} \Rightarrow \post{}(\sv{Output},\cv{Output})
$$

The \sdef{} antecedent states that we are only interested in proving equivalence for
well-defined executions of \sprog{}, i.e., executions that satisfy all assertions expressed
using the {\tt assuming-do} statement.
The \cfits{} antecedent states that we prove equivalence under the assumption that \cprog{}'s memory
requirements fit within the available system memory i.e., only for those executions of \cprog{}
in which all memory allocation requests (through {\tt malloc} calls) are successful.

The returned values of \sprog{} and \cprog{} form their observable outputs.
For \sprog{}, the returned values are explicit and may include ADT values.
For \cprog{}, observables include the returned value alongside the implicit memory state
at program exit.
The postcondition \post{} relates these outputs of the two programs.
The pair $(\pre{},\post{})$ represents the input-output behaviour of \cprog{} in terms of the specification \sprog{},
and is called the {\em input-output specification}.
In general, \SpecL{} and C sources may contain multiple top-level procedures, with calls to each other.
In this case, we are interested in finding equivalence between each pair
of \sprog{} and \cprog{} procedures with respect to their input-output specification.

Sometimes, the user may be interested in constraining the nature of inputs to \cprog{}
for the purpose of checking equivalence only for {\em well-defined} inputs.
In those circumstances, we use a combination of \pre{} and \sdef{} to constrain
the execution of \cprog{} to inputs for which we are interested in proving equivalence.
For example, the C library function {\tt strlen(\type{char}* \cv{str})} is well-defined only if \cv{str}
represents a valid null character terminated string.
This includes the assumption that the pointer \cv{str} may not be null.
Since \SpecL{} has no notion of pointers, we expose this conditional well-definedness of C strings
through an explicit constructor e.g. \cons{SInvalid} for the \type{String} ADT defined as:
$$
\type{String}=\cons{SInvalid}\ |\ \cons{SNil}\ |\ \cons{SCons}(\type{i8}, \type{String})
$$
\sdef{} asserts $\neg(\sumIs{\sv{str}}{SInvalid})$ (using {\tt assuming-do}) and
the precondition \pre{} contains the relation $(\sumIs{\sv{str}}{SInvalid}) \Leftrightarrow (\cv{str}=0)$.
Hence, \sdef{} and \pre{} ensure that we compute equivalence for those
executions of \sprog{} and \cprog{} where the input strings are well-defined.
A similar strategy is employed for other functions as explored later in \cref{sec:results}.

\subsection{Control Flow Graph Representation}
\label{sec:ir}
As outlined in \cref{sec:motivatingexample}, we convert both \SpecL{} and C programs to a common
abstract representation called the `Control Flow Graph' (CFG for short).
This process involves converting both programs to a linear equivalent representation called the IR.
IR is a Three-Address-Code (3AC) style intermediate representation.
We often omit intermediate registers in the IR for brevity,
and refer to this as the {\em abstracted} IR.

\input{chapters/figures/figSumListSpecAndC.tex}
\input{chapters/figures/figSumListSpecAndCIRAndCFG.tex}

We have already seen the the IRs (in \cref{fig:llAllocSpecIR,fig:llAllocCIR}) for the \SpecL{} and C programs
that construct lists in \cref{fig:llAllocSpec,fig:llAllocC}.
\Cref{fig:llTraverseSpec,fig:llTraverseC} show \SpecL{} and C programs that traverse a list
and return the sum of all the values in it.
The corresponding IR programs are shown in \cref{fig:llTraverseSpecIR,fig:llTraverseCIR}.

During conversion of a \SpecL{} source to its IR,
(a) {\tt match} statements are lowered to explicit {\tt if-else} conditionals where each branch
is associated with a {\tt match} branch,
(b) all tail recursive calls are converted to loops while non-tail calls are preserved and
(c) all helper functions are inlined at their call-site.
For example, during conversion of \SpecL{} program in \cref{fig:llTraverseSpec},
(a) the {\tt match} statement in \apc{3} is converted to {\tt if-else}
(b) the tail recursive function {\tt sum\_list\_impl} is converted to a loop,
and (c) the helper function {\tt sum\_list\_impl} is inlined,
to obtain the IR in \cref{fig:llTraverseSpecIR}.

Similarly, the following is performed during conversion of a C source to its IR:
(a) the sizes and memory layouts of both scalar (e.g., \type{int})
and compound (e.g., \type{struct}) types are concretized,
(b) the program memory state along with loads and stores on the memory are made explicit and
(c) we annotate {\tt malloc} calls with their call-site i.e. IR PC.
For example, during conversion of C program in \cref{fig:llAllocC} to IR (in \cref{fig:llAllocCIR}),
(a) the size of pointer and \type{unsigned} types are fixed to 32-bits (i.e. \type{i32}),
(b) \mem{} is used to represent the program memory with explicit writes at \cpc{5} and \cpc{6},
and (c) {\tt malloc$_\cpc{4}$} is annotated with its call-site \cpc{4}.

The IR supports both scalar and ADT types available in \SpecL{}.
Each ADT value is modeled as a key-value dictionary that maps
each of its field names to the constituent values.
These key-value pairs are accessed using the {\em accessor} operator,
e.g., \prodAccess{l}{val} and \prodAccess{l}{next} represents the first and second
fields of the \cons{LCons} constructor in \cref{fig:llTraverseSpecIR}.
The IR also allows querying the top-level data constructor of an ADT value
using the {\em sum-is} operator, e.g., \sumIs{l}{LNil} in \cref{fig:llTraverseSpecIR}.
The \field{val} field is associated with the \cons{LCons} data constructor
and evidently, \prodAccess{l}{val} is only {\em well-formed} if \sumIs{l}{LCons}.
Importantly, the construction of the \SpecL{} IR ensures the well-formedness of all expressions.
Using {\em accessor} and {\em sum-is} operators, a \type{List} value $l$ can be expanded as:

\begin{equation}
\label{eqn:specDeconstruct}
U_S: l = \sumIf{\sumIs{l}{LNil}} \  \sumThen{\cons{LNil}} \  \sumElse{\cons{LCons}(\prodAccess{l}{val}, \prodAccess{l}{next})}
\end{equation}

In this expanded representation of $l$,
the {\em sum-deconstruction} operator `\sumDtor{}'
conditionally deconstructs the sum type into its variants \cons{LNil} and \cons{LCons}.
The {\em underlined} \sumDtor{} operator is a stricter version of {\tt if-then-else}, and is only used for ADT values.
An \sumDtor{} expression $e$ (for an ADT type $T$) must satisfy the following properties:
(a) $e$ has exactly one branch for each data construction of $T$ (in the order they are defined),
and (b) the branch associated with the data constructor $V$ has the form $V(e_1,e_2,\dots)$ i.e. its top-level operator is $V$.
For example, an \sumDtor{} expression for the \type{List} type must be of the form:
`\sumIf{e_1} \sumThen{\cons{LNil}} \sumElse{\cons{LCons}(e_2,e_3)}' for some expressions $e_1,e_2,e_3$.
\Cref{eqn:specDeconstruct} is called the {\em unrolling procedure} for the \type{List} variable $l$.
We can similarly define the unrolling procedure for any ADT variable (based on the definition of the ADT).

The C memory is modeled as a byte-addressable array \mem{} in the IR
and pointers are converted to bitvectors.
``\memRead{\mem{}}{p}{T}'' represents a memory load operation and is equal to the bytes
at addresses [$p$, $p$+\sizeof{T}) in \mem{}, interpreted as a value of type `\type{T}'.
Similarly, ``\memWrite{\mem{}}{p}{v}{T}'' represents a memory store operation and is equal to \mem{}
everywhere except at addresses [$p$, $p$+\sizeof{T}) which contains
the value $v$ of type `\type{T}' (e.g., \cpc{5} in \cref{fig:llAllocCIR}).
We use the following two C-like syntaxes to represent more complex memory loads succintly:

\begin{enumerate}
\item ``\structPointer{p}{\mem{}}{T}{f}'' is equivalent to ``\memRead{\mem}{p+\offsetof{T}{f}}{\typeof{T.f}}''
i.e., it returns the bytes in the memory array \mem{} starting at address `$p+\offsetof{T}{f}$'
and interpreted as a value of type `\typeof{T.f}'.

\item ``\arrIndex{p}{i}{\mem{}}{T}'' is equivalent to ``\memRead{\mem}{p+i \times \sizeof{T}}{T}''
i.e., it returns the bytes in the memory array \mem{} starting at address `$p+i \times \sizeof{T}$'
and interpreted as a value of type `\type{T}'.
Interestingly, $\memRead{\mem{}}{p}{T} = \arrIndex{p}{0}{\mem{}}{}$.
\end{enumerate}

\noindent Recall that the size and memory layout of each type is concretized in the IR,
and hence the values `\offsetof{T}{f}' and `\sizeof{T}' are known constants.
We use the `\addrof{}' operator to extract the address of a memory load expression:
``\addrof{\memRead{\mem{}}{p}{T}}'' is equivalent to $p$.
For example, at PC \cpc{5} in \cref{fig:llAllocCIR}, $\addrof{\structPointer{\mathnormal{p}}{\mem{}}{lnode}{val}} \Leftrightarrow p+\offsetof{lnode}{val}$.

\Cref{fig:llTraverseSpecCFG,fig:llTraverseCCFG} show the Control-Flow Graph (CFG) representation
of the \SpecL{} and C IRs in \cref{fig:llTraverseSpecIR,fig:llTraverseCIR} respectively.
Each CFG node represents a program point (i.e. IR PC) and edges represent
transitions through execution of instructions.
Each edge is associated with:
(a) an {\em edge condition} (the condition under which that edge is taken),
(b) a {\em transfer function} (how the program state is mutated if that edge is taken) and
(c) a {\em UB assumption} (what condition should be true for the program execution
to be well-defined across this edge).
In \SpecL{}, assertions expressed using the {\tt assuming-do} statement
form the UB assumptions.
For brevity, we often represent a sequence of instructions with a single edge, e.g.,
in \cref{fig:llAllocCCFG}, the edge \cpath{5,3} represents the path \cpath{5,6,7,8,3}.
In such a case, the transfer function of the edge is the composition of the sequence of instructions.
We omit these transfer functions in the CFG figures and only show the edge conditions (unless they are {\em true}).
Henceforth, We refer to the IR programs as \SpecL{} and C directly unless a distinction is necessary.

\input{chapters/figures/figSumListProductCFGAndInvs.tex}

\subsection{Bisimulation Relation}
\label{sec:bisim}
Recall that,
we construct a {\em bisimulation relation} to identify equivalence between \SpecL{} and C procedures.
A bisimulation relation correlates the transitions of \sprog{} and \cprog{} in lockstep, such that the
lockstep execution ensures identical observable behaviour.
A bisimulation relation between two programs can be represented using a {\em product program}
\cite{covac} and the CFG representation of a product program is called a {\em product}-CFG.
\Cref{fig:llTraverseProduct} shows a product-CFG, that encodes the lockstep execution
(bisimulation relation) between the CFGs in \cref{fig:llTraverseSpecCFG,fig:llTraverseCCFG}.

A node in the product-CFG is formed by pairing nodes of \sprog{} and \cprog{},
e.g., (\scpc{2}{2}) is formed by pairing \spc{2} and \cpc{2}.
If the lockstep execution of both programs is at node (\scpc{2}{2}) in the product-CFG,
then \sprog{}'s execution is at \spc{2} and \cprog{}'s execution is at \cpc{2}.
The start node (\scpc{0}{0}) of the product-CFG correlates the start nodes of CFGs of \sprog{} and \cprog{}.
Similarly, the exit node (\scpc{E}{E}) correlates the exit nodes of both programs.

An edge in the product-CFG is formed by pairing a {\em path} (a sequence of edges) in \sprog{}
with a path in \cprog{}.
A product-CFG edge encodes the lockstep execution of its correlated paths.
For example, the product-CFG edge \scedge{2}{2}{2}{2} is formed by pairing
\spath{2,5,2} and \cpath{2,4,2} in \cref{fig:llTraverseSpecCFG,fig:llTraverseCCFG} respectively,
and represents that when \sprog{} makes the transition \spath{2,5,2}, \cprog{} makes the transition \cpath{2,4,2}
in lockstep.
In general, a product-CFG edge $e$ may correlate a finite path \sv{\rho} in \sprog{} with a finite path
\cv{\rho} in \cprog{}, written $e=(\sv{\rho},\cv{\rho})$.
The empty path $\epsilon$ in \sprog{} may be correlated with a finite path in \cprog{}.
However, a product-CFG is only well-formed (i.e. represents a valid bisimulation relation)
if no loop path in \cprog{} is correlated with $\epsilon$ in \sprog{}.
For example, \cref{fig:llAllocProductCFG} shows the product-CFG between the programs
in \cref{fig:llAllocSpecIRCFG,fig:llAllocCCFG} respectively.
The edges \scedge{3}{3}{3}{4} and \scedge{3}{4}{3}{5} correlate the empty path $\epsilon$
with the non-empty paths \cpath{3,4} and \cpath{4,5} respectively.
However, the only loop path \cpath{3,4,5,3} in \cprog{} is still correlated with the non-empty path \spath{3,5,3}
in \sprog{} and thus, the product-CFG in \cref{fig:llAllocProductCFG} satisfies this well-formedness criterion.

At the start node (\scpc{0}{0}) of the product-CFG in \cref{fig:llTraverseProduct},
the precondition \pre{} (labeled \circled{\small P})
ensures equality of input lists \sv{l} and \cv{l} at procedure entries.
{\em Inductive invariants} (labeled \circled{I}) are inferred
at each intermediate product-CFG node (e.g., (\scpc{2}{2})) that relate
the values of \sprog{} with values and memory state of \cprog{}.
At the exit node (\scpc{E}{E}) of the product-CFG, the postcondition \post{} (labeled \circled{\small P})
represents equality of observable outputs and forms our overall proof obligation.
Assuming that the precondition \pre{} (\circled{\small P}) holds at the entry node (\scpc{0}{0}),
a bisimulation check involves checking that the inductive invariants (\circled{\small I}) hold too,
and consequently the postcondition \post{} (\circled{\small E}) holds at the exit node (\scpc{E}{E}).
The input-output specification (i.e. $(\pre{},\post{})$) is manually provided by the user
while all inductive invariants are identified by an invariant inference algorithm described in \cref{sec:invinferalgo}.

\subsection{Recursive Relation}
\label{sec:recrel}
In \cref{sec:motivatingexample}, we briefly introduced a lifting constructor (\lift{list}{}{lnode})
and \recursiveRelations{}.
In \cref{fig:llTraverseProductInv}, the precondition (\circled{\small P}) is another instance
of a \recursiveRelation{}:
``\sv{l} \indEq{} \lifted{list}{\mem{}}{lnode}{\cv{l}}'' where \sv{l} and \cv{l}
represent the input arguments to the \SpecL{} and C procedures respectively,
\type{lnode} is the C \type{struct} type that contains the \field{val} and \field{next} fields (defined at \bpc{0} in \cref{fig:llTraverseC}),
and \mem{} is the byte-addressable array representing the current memory state of the C program.
$l_1 \indEq{} l_2$ is read {\em $l_1$ is recursively equal to $l_2$} and is semantically equivalent
to $l_1 = l_2$. The `\indEq{}' simply emphasizes that $l_1$ and $l_2$ are (possibly recursive) ADT values.
The lifting constructor \lift{list}{}{lnode} `lifts' a C pointer value $p$
(pointing to an object of type \type{struct lnode}) and
memory state \mem{} to a (possibly infinite in case of a circular list) \type{List} value,
and is defined through its {\em unrolling procedure} as follows:

\begin{equation}
\label{eqn:clist}
\begin{split}
U_C:\ &\lifted{list}{\mem{}}{lnode}{p \ctype{i32}} = \sumIf{p=0} \ \sumThen{\cons{LNil}} \\ & \qquad\qquad\ \ \ \sumElse{\cons{LCons}(\structPointer{p}{\mem{}}{lnode}{val}, \lifted{list}{\mem{}}{lnode}{\structPointer{p}{\mem{}}{lnode}{next}})}
\end{split}
\end{equation}

Note the recursive nature of the lifting constructor \lift{list}{}{lnode}: if the pointer $p$ is zero
(i.e. $p$ is a null pointer), then it represents the empty list \cons{LNil};
otherwise it represents the list formed by \cons{LCons}-ing the value stored at
\structPointer{p}{\mem{}}{lnode}{val} in memory \mem{} and the list formed by recursively
lifting \structPointer{p}{\mem{}}{lnode}{next} through \lift{list}{}{lnode}.
\lifted{list}{\mem{}}{lnode}{p} allows us to adapt a C linked list (formed by chasing pointers
in the memory \mem{}) to a \type{List} value and compare it with a \SpecL{} \type{List}
value for equality.

\subsection{Proof Obligations}
\label{sec:proofobl}
As previously discussed, algorithms for (a) incremental construction of a Product-CFG
and (b) inference of invariants at intermediate PCs in the (partially constructed) product-CFG, are
based on prior work\cite{oopsla20} and discussed subsequently in \cref{sec:searchalgo,sec:invinferalgo}.
For now, we discuss the proof obligations that arise from a given product-CFG.
Recall that a bisimulation check involves checking that all inductive invariants
(and the postcondition \post{}) hold at their associated product-CFG nodes.

We use relational Hoare triples to express these proof obligations \cite{relationalHoareLogic,hoareTriple}.
If $\phi$ denotes a predicate relating the machine states of \sprog{} and \cprog{}, then
for a product-CFG edge $e=(\sv{\rho},\cv{\rho})$, \hoareTriple{\phi_s}{e}{\phi_d}
denotes the condition:
if any machine states \sv{\sigma} and \cv{\sigma} of programs \sprog{} and \cprog{} are related through
precondition $\phi_s(\sv{\sigma},\cv{\sigma})$ and the finite paths \sv{\rho} and \cv{\rho}
are executed in \sprog{} and \cprog{} respectively,
then execution terminates normally in states $\sv{\sigma}^{'}$ (for \sprog{}) and
$\cv{\sigma}^{'}$ (for \cprog{}) and postcondition $\phi_d(\sv{\sigma}^{'},\cv{\sigma}^{'})$ holds.

For every product-CFG edge $e = (s \rightarrow d) = (\sv{\rho}, \cv{\rho})$,
we are interested in proving: \hoareTriple{\phi_s}{\sv{\rho},\cv{\rho}}{\phi_d},
where $\phi_s$ and $\phi_d$ are the node invariants at the product-CFG nodes $s$ and $d$
respectively.
The weakest-precondition transformer is used to translate a Hoare triple
\hoareTriple{\phi_s}{\sv{\rho},\cv{\rho}}{\phi_d} to the following
first-order logic formula:

\begin{equation}
\label{eqn:firstOrderFormula}
(\phi_s \land {\tt pathcond}_{\sv{\rho}} \land {\tt pathcond}_{\cv{\rho}} \land {\tt ubfree}_{\sv{\rho}}) \Rightarrow {\tt WP}_{{\sv{\rho},\cv{\rho}}}(\phi_d)
\end{equation}

Here, ${\tt pathcond}_{\rho_X}$ represents the condition that path $\rho$ is taken in program $X$
and ${\tt ubfree}_{\sv{\rho}}$ represents the condition that execution of \sprog{} along path $\sv{\rho}$
is free of undefined behaviour.
${\tt WP}_{{\sv{\rho},\cv{\rho}}}(\phi_d)$ represents the weakest-precondition
of the predicate $\phi_d$ across the product-CFG edge $e = (\sv{\rho},\cv{\rho})$.
From now on, we will use `\lhs{}' and `\rhs{}' to refer to the antecedent and consequent of
the implication operator `$\Rightarrow$' in \cref{eqn:firstOrderFormula}.

For example, checking that the loop invariant \circled{\small I2}
$\sv{l} \indEq{} \lifted{list}{\mem{}}{lnode}{\cv{l}}$ holds at (\scpc{2}{2}) in \cref{fig:llTraverseProduct}
requires us to prove the following two proof obligations:
\circled{1} \hoareTriple{\scpcinv{0}{0}}{\spath{0,2},\cpath{0,2}}{\sv{l} \indEq{} \lifted{list}{\mem{}}{lnode}{\cv{l}}} and
\circled{2} \hoareTriple{\scpcinv{2}{2}}{\spath{2,5,2},\cpath{2,4,2}}{\sv{l} \indEq{} \lifted{list}{\mem{}}{lnode}{\cv{l}}}.
Using weakest precondition predicate transformer, the proof obligation \circled{2} reduces to the following first-order logic formula:

\begin{equation}
\label{eqn:firstOrderFormulaExample}
\begin{split}
\sv{l} \indEq{} \lifted{list}{\mem{}}{lnode}{\cv{l}} \land \sv{sum} = \cv{sum}
\land (\sumIs{\sv{l}}{LCons}) \land (\cv{l} \neq 0) \\ \Rightarrow
\prodAccess{\sv{l}}{next} \indEq{} \lifted{list}{\mem{}}{lnode}{\structPointer{\cv{l}}{\mem{}}{lnode}{next}}
\end{split}
\end{equation}

Due to the presence of \recursiveRelations{}, these proof queries
(e.g., \cref{eqn:firstOrderFormulaExample}) cannot be solved directly by
off-the-shelf solvers and require special handling.
The next chapter illustrates our proof discharge algorithm for solving proof queries
involving \recursiveRelations{}.
