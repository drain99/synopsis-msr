\begin{figure}[t!]
\begin{algorithm}[H]
\begin{footnotesize}
\DontPrintSemicolon
\everypar={\nl}
\SetAlgoLined
\SetKwProg{Fn}{Function}{}{end}
\Fn{$decompose(l_1,l_2)$}{
  $P \mapsfrom true$\\
  $\hat{l}_1 \mapsfrom {\tt canonicalize}(l_1)$\\
  $\hat{l}_2 \mapsfrom {\tt canonicalize}(l_2)$\\
  $R   \mapsfrom \Theta(true,\hat{l}_1,true,\hat{l}_2)$\\
  \lIf{$R = \cons{Fail}$}{\Return{$false$}}
  \ForEach{$\corrtuple{p_1}{a_1}{p_2}{a_2} \keyword{in} R$}{
    \uIf{$a_1 \keyword{is} scalar$}{
      $P \mapsfrom P \land ((p_1 \land p_2) \rightarrow (a_1 = a_2))$\\
    }
    \Else{
      $P \mapsfrom P \land ((p_1 \land p_2) \rightarrow (a_1 \indEq{} a_2))$\\
    }
  }
  \Return{$P$}
}
\end{footnotesize}
\caption{Algorithm for decomposing a \recursiveRelation{}}
\end{algorithm}
\caption{\label{algo:decompose}Pseudocode of the algorithm responsible for decomposing
a \recursiveRelation{} through unification.}
\end{figure}