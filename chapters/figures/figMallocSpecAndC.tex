\begin{figure}[t]
\begin{tabular}{cc}
\begin{subfigure}[b]{.59\textwidth}
\begin{center}
\begin{allLangEnvScript}
~{\tiny \textcolor{mygray}{A0:}}~ type List = LNil | LCons (val:i32, tail:List).
~{\tiny \textcolor{mygray}{A1:}}~
~{\tiny \textcolor{mygray}{A2:}}~ fn mk_list_impl (n:i32) (i:i32) (l:List):List =
~{\tiny \textcolor{mygray}{A3:}}~    if ${\tt i \geq_u n}$
~{\tiny \textcolor{mygray}{A4:}}~       then l
~{\tiny \textcolor{mygray}{A5:}}~       else make_list_impl(n, i + ${\tt 1_{i32}}$, LCons(i, l)).
~{\tiny \textcolor{mygray}{A6:}}~
~{\tiny \textcolor{mygray}{A7:}}~ fn mk_list (n:i32):List = mk_list_impl(n, ${\tt 0_{i32}}$, LNil).
\end{allLangEnvScript}
\end{center}
\caption{\label{fig:llAllocSpec}Spec Program}
\end{subfigure}%
&
\begin{subfigure}[b]{0.41\textwidth}
\begin{center}
\begin{allLangEnvScript}
~{\tiny \textcolor{mygray}{S0:}}~ List mk_list (i32 n) {
~{\tiny \textcolor{mygray}{S1:}}~   List l $\coloneq$ LNil;
~{\tiny \textcolor{mygray}{S2:}}~   i32  i $\coloneq$ ${\tt 0_{i32}}$;
~{\tiny \textcolor{mygray}{S3:}}~   while $\mathrm{\tt \neg (i \geq_{u} n)}$:
~{\tiny \textcolor{mygray}{S4:}}~     l $\coloneq$ LCons(i, l);
~{\tiny \textcolor{mygray}{S5:}}~     i $\coloneq$ i + ${\tt 1_{i32}}$;
~{\tiny \textcolor{mygray}{S6:}}~   return l;
~{\tiny \textcolor{mygray}{SE:}}~ }
\end{allLangEnvScript}
\end{center}
\caption{\label{fig:llAllocSpecIR}(Abstracted) Spec IR}
\end{subfigure}%
\\
\begin{subfigure}[b]{0.59\textwidth}
\begin{center}
\begin{allLangEnvScript}
~{\tiny \textcolor{mygray}{B0: }}~ typedef struct lnode {
~{\tiny \textcolor{mygray}{B1: }}~   unsigned val; struct lnode* next; } lnode;
~{\tiny \textcolor{mygray}{B2: }}~ 
~{\tiny \textcolor{mygray}{B3: }}~ lnode* mk_list(unsigned n) {
~{\tiny \textcolor{mygray}{B4: }}~   lnode* l = NULL;
~{\tiny \textcolor{mygray}{B5: }}~   for (unsigned i = 0; i < n; ++i) {                     $\phantom{m \coloneq \mathrm{\tt m[\&\structPointer{\tt p}{m}{\tt lnode}{val} \leftarrow i]_{i32}};}$
~{\tiny \textcolor{mygray}{B6: }}~     lnode* p = malloc(sizeof lnode);                      $\phantom{m \coloneq \mathrm{\tt m[\&\structPointer{\tt p}{m}{\tt lnode}{val} \leftarrow l]_{i32}};}$
~{\tiny \textcolor{mygray}{B7: }}~     p$\rightarrow$val = i; p$\rightarrow$next = l; l = p;
~{\tiny \textcolor{mygray}{B8: }}~   }
~{\tiny \textcolor{mygray}{B9:}}~   return l;
~{\tiny \textcolor{mygray}{B10:}}~ }
\end{allLangEnvScript}
\end{center}
\caption{\label{fig:llAllocC}C Program with {\tt malloc()}}
\end{subfigure}%
&
\begin{subfigure}[b]{0.41\textwidth}
\begin{center}
\begin{allLangEnvScript}
~{\tiny \textcolor{mygray}{C0:}}~ i32 mk_list (i32 n) {
~{\tiny \textcolor{mygray}{C1:}}~   i32 l $\coloneq$ ${\tt 0_{i32}}$;
~{\tiny \textcolor{mygray}{C2:}}~   i32 i $\coloneq$ ${\tt 0_{i32}}$;
~{\tiny \textcolor{mygray}{C3:}}~   while ${\tt i <_{u} n}$:
~{\tiny \textcolor{mygray}{C4:}}~     i32 p $\coloneq$ malloc$_{\tt C4}$(sizeof lnode);
~{\tiny \textcolor{mygray}{C5:}}~     m $\coloneq$ $\mathrm{\tt m[\&\structPointer{\tt p}{m}{\tt lnode}{val} \leftarrow i]_{i32}}$;
~{\tiny \textcolor{mygray}{C6:}}~     m $\coloneq$ $\mathrm{\tt m[\&\structPointer{\tt p}{m}{\tt lnode}{next} \leftarrow l]_{i32}}$;
~{\tiny \textcolor{mygray}{C7:}}~     l $\coloneq$ p;
~{\tiny \textcolor{mygray}{C8:}}~     i $\coloneq$ i + ${\tt 1_{i32}}$;
~{\tiny \textcolor{mygray}{C9:}}~   return l;
~{\tiny \textcolor{mygray}{CE:}}~ }
\end{allLangEnvScript}
\end{center}
\caption{\label{fig:llAllocCIR}(Abstracted) C IR}
\end{subfigure}%
\\
\end{tabular}
\caption{\label{fig:llAllocSpecAndC}Example Spec and C programs and their lowerings to IR.}
\end{figure}
