\section{Spec-to-C Equivalence Checker}
\label{sec:spectocalgo}
In this section, we describe our automatic equivalence checker algorithm \toolName{}.
\toolName{} is able to search for and (hopefully) find a bisimulation based proof of equivalence
between a \SpecL{} and C procedure.
As described in \cref{sec:contribs}, \toolName{} is based on three primary algorithms:
(a) an algorithm to incrementally construct a product-CFG by correlating program executions across
the \SpecL{} and C procedures respectively,
(b) an algorithm to identify inductive invariants at intermediate PCs in the (partially constructed)
product-CFG, and (c) an algorithm for solving proof obligations generated by the first two algorithms.
The last section illustrates our proof discharge algorithm through sample \SpecL{} and C programs.
We start by describing our counterexample-guided best-first search algorithm for
construction of a product-CFG in \cref{sec:searchalgo}.
This is followed by a description of our counterexample-guided invariant inference algorithm in \cref{sec:invinferalgo}.
We finish with a comprehensive analysis of our proof discharge algorithm and its related subprocedures.

\subsection{Counterexample-guided Product-CFG Construction}
\label{sec:searchalgo}
\toolName{} constructs a product-CFG incrementally to search for an observably-equivalent
bisimulation relation between the individual CFGs of a \SpecL{} program $S$ and a C program $C$.
Multiple candidate product-CFGs are partially constructed during this search;
the search completes when one of these candidates yield an equivalence proof.

{\em Anchor nodes} are identified in the CFGs of $S$ and $C$, and represents the source and destination nodes (i.e. IR PCs)
of paths chosen to be correlated between the two programs.
The algorithm ensures that every cycle in both $S$ and $C$ contains at least one anchor node.
The start and exit nodes are always anchor nodes.
Also, for every procedure call, the nodes just before and after its callsite are considered anchor nodes.
For example, in \cref{fig:llAllocCCFG}, \cpc{4} and \cpc{5} are anchor nodes around the call to {\tt malloc}.
The selected anchor nodes in the CFGs in \cref{fig:llAllocSpecIRCFG,fig:llAllocCCFG} are:
$\{ \spc{0},\spc{3},\spc{E} \}$ and $\{ \cpc{0}, \cpc{3}, \cpc{4}, \cpc{5}, \cpc{E} \}$ respectively.
For each anchor node in $C$, our search algorithm searches for a correlated anchor node in $S$ --- if
a product-CFG $\pi$ contains a product-CFG node  $(n_S\!:\!n_C)$, then $\pi$
correlates node $n_C$ in $C$ with node $n_S$ in $S$.
The search procedure begins with a single partially-constructed product-CFG $\pi_0$.
$\pi_0$ contains exactly one node (\scpc{0}{0}) that encodes the correlation of the entry nodes
(i.e. \spc{0} and \cpc{0}) of the two input CFGs.

At each step of the incremental construction process, a node $(n_S\!:\!n_C)$ is chosen in a product-CFG $\pi$
and a path $\rho_C$ in $C$'s CFG starting at $n_C$ (and ending at an anchor node in $C$) is selected.
Then, we enumerate the potential correlations of the path $\rho_C$ in the $S$'s CFG.
For example, during construction of the product-CFG shown in \cref{fig:llAllocProductCFG},
say we select the product-CFG node (\scpc{3}{3}).
We choose the $C$ path \cpath{3,4} and enumerate its potential correlations (i.e. paths in $S$ starting at \spc{3}):
$\epsilon$, \spath{3,5,3}, \spath{3,5,3,5,3}, \ldots, $\pathset{S3,(\pathset{S5,S3})^\mu}$.
The {\em unroll factor} $\mu$ is a fixed parameter of the algorithm and represents the maximum number of iterations of a loop (in $S$),
that can be correlated with a path $\rho_C$ in $C$.
Importantly, for paths $\rho_S$ (in $S$) and $\rho_C$ (in $C$) to be considered for correlation,
they must begin and end at anchor nodes, i.e. the path \spath{3,5} is skipped during enumeration.
Moreoever, the path $\rho_C$ may not contain anchor nodes in the middle.
Hence, the path \cpath{3,4,5} is not considered for correlation.

For each enumerated correlation possibility $(\rho_S,\rho_C)$, a separate product-CFG $\pi'$ is
created (by cloning $\pi$) and a new product-CFG edge $e=(\rho_S,\rho_C)$ is added to $\pi'$.
The head of the product-CFG edge $e$ is the (potentially newly added) product-CFG node representing
the correlation of the end-points of paths $\rho_S$ and $\rho_C$. For example, the node {\tt (S3:C4)} is added
to the product-CFG if it correlates paths $\epsilon$ and \cpath{3,4} starting at (\scpc{3}{3}).
For each node $s$ in a product-CFG $\pi$, we maintain a small number of
concrete machine state pairs (of $S$ and $C$) at $s$.
The concrete machine state pairs at $s$ are obtained as counterexamples to an unsucessful proof
obligation \hoareTriple{\phi_s}{s \rightarrow d}{\phi_d} (for some edge $s \rightarrow d$ and node $d$ in $\pi$).
Thus, by construction, these counterexamples represent concrete state pairs that may potentially occur
at $s$ during the lockstep execution encoded by $\pi$.

To evaluate the promise of a possible correlation $(\rho_S,\rho_C)$ starting at node $s$
in product-CFG $\pi$, we examine the execution behavior of the counterexamples at $s$ on
the product-CFG edge $e=(s\rightarrow d)=(\rho_S,\rho_C)$.
If the counterexamples ensure that the machine states remain related at $d$,
then that candidate correlation is ranked higher.
This ranking criterion is based on prior work \cite{oopsla20}.
A best-first search (BFS) procedure based on this ranking criterion is used to incrementally construct
a product-CFG (starting from $\pi_0$) that proves bisimulation.
For each intermediate candidate product-CFG $\pi$ generated during this search procedure,
an automatic invariant inference procedure (discussed next in \cref{sec:invinferalgo}) is
used to identify invariants at all the nodes in $\pi$.
The counterexamples obtained from the proof obligations generated by this invariant inference
procedure are added to the respective nodes in $\pi$; these counterexamples help rank
future correlations starting at those nodes.

If after invariant inference, we realize that an intermediate candidate product-CFG $\pi_1$
is not promising enough, we backtrack and choose another candidate product-CFG $\pi_2$
and explore the potential correlations that can be added to $\pi_2$.
Thus, a product-CFG is constructed one edge at a time.
If at any stage, a product-CFG $\pi$ contains correlations for every path in $C$
and invariants ensure equal observables (i.e. $Post$ holds at correlated exit nodes),
we have successfully shown equivalence.
This counterexample-guided BFS procedure is similar to the one described in prior work on
the Counter algorithm \cite{oopsla20}.

\subsubsection{Correlation in the Presence of Procedure Calls}
\label{sec:correlfcalls}
Recall that a procedure $\delta$ in $S$ or $C$ may make calls to other procedures (including self calls),
e.g., allocation of memory in C, traversal of a tree data structure.
Calls to memory allocation functions in $C$ (i.e. {\tt malloc}) are handled by correlating
the function call edge with the empty path ($\epsilon$) in $S$.
For example, in the product-CFG shown in \cref{fig:llAllocProductCFG}, the {\tt malloc} edge \cpath{4,5} in $C$
is correlated with $\epsilon$ in $S$.

For all other procedure calls, our correlation algorithm (in \cref{sec:searchalgo}) ensures that the anchor nodes
around such a callsite are correlated one-to-one across both procedures.
For example, let there be a call to procedure $\delta'$ in $S$ at PC $n_S$, i.e. $n_S$ is the call-site.
Let us denote the program point just after this call-site as $n'_S$.
Let {\tt args}$_{n_S}$ represent the values of the actual arguments of this procedure call (at $n_S$).
Let {\tt ret}$_{n'_S}$ represent the value returned by this procedure call (at $n'_S$).
Similarly, for a procedure call $\delta'$ in $C$, let $n_C$, $n'_C$, {\tt args}$_{n_C}$ and {\tt ret}$_{n'_C}$
represent the procedure call call-site, program point just after call-site,
the values of the actual arguments and the value returned respectively.
Our algorithm ensures that the only correlation possible in a product-CFG $\pi$ for these program points are
$(n_S:n_C)$ and $(n'_S:n'_C)$.

We utilize the user-supplied input-output specification for $\delta'$ (say $(Pre_{\delta'},Post_{\delta'})$)
to obtain the desired invariants at nodes $(n_S:n_C)$ and $(n'_S:n'_C)$ in the product-CFG.
A successful proof must {\em ensure} that $Pre_{\delta'}$({\tt args}$_{n_S}$,{\tt args}$_{n_C}$,$\mem{}_{n_C}$)
holds at $(n_S:n_C)$.
Further, the proof can {\em assume} that $Post_{\delta'}$({\tt ret}$_{n'_S}$,{\tt ret}$_{n'_C}$,$\mem{}_{n'_C}$)
holds at $(n'_S:n'_C)$.
Here, $\mem{}_{n_C}$ and $\mem{}_{n'_C}$ represents the memory states in $C$ at $n_C$ and $n'_C$ respectively.
Thus, for a procedure call, we inductively prove the precondition (on the arguments of the procedure call) at $(n_S:n_C)$
and assume the postcondition (on the return values of the procedure call) at $(n'_S:n'_C)$.

\input{chapters/figures/figInvariantDFA.tex}
\input{chapters/figures/figTfAndInvGrammar.tex}

\subsection{Invariant Inference and Counterexample Generation}
\label{sec:invinferalgo}
We formulate our counterexample-guided invariant inference algorithm as a dataflow analysis
as shown in \cref{tab:invinferalgodfa}.
The invariant inference procedure is responsible for inferring invariants $\phi_n$ at each intermediate
node $n$ of a (partially constructed) product-CFG, while also generating a set of counterexamples
$\Gamma_n$ that represents the potential concrete machine states at $n$.

Given the invariants and counterexamples at node $s$: ($\phi_s,\Gamma_s$),
the transfer function initializes the new candidate set of counterexamples at $d$ ($\Gamma^{can}_{d}$)
with the current set of counterexamples at $d$ ($\Gamma_{d}$) {\em union}-ed with
the counterexamples obtained by executing $\Gamma_s$ on edge $e$ ({\tt exec}$_e$).
The candidate invariant at $d$ ($\phi^{can}_d$) is computed as the strongest cover
of $\Gamma^{can}_{d}$ ($StrongestInvCover()$).
At each step, the transfer function attempts to prove $\{\phi_s\} (e) \{\phi^{can}_d\}$
(through a call to $Prove()$).
If the proof succeeds ($Prove()$ returns true), the candidate invariant $\phi^{can}_d$ is returned alongwith
the counterexamples $\Gamma^{can}_d$ learned so far.
Else the candidate invariant $\phi^{can}_d$ is weakened using the counterexamples obtained
(i.e. $\gamma_s$) and the proof attempt is repeated.

The candidate invariants are drawn from the predicate grammar shown in \cref{fig:invinfergrammar}.
The predicate grammar allows affine and inequality relations between bitvector values of both
programs, as well as, \recursiveRelations{} between an ADT value in \SpecL{} and a {\em lifted} ADT value in $C$.
The candidate lifting constructors are derived from the lifting constructors
present in the precondition $Pre$ and the position $Post$, as supplied by the user.
More sophisticated strategies for deduction of new lifting constructors is possible.

{\em StrongestInvCover()} for affine relations involve
identifying the basis vectors of the kernel of the
matrix formed by the counterexamples in the bitvector
domain \cite{esop05,semalign}.
For inequality relations, {\em StrongestInvCover($\Gamma$)}
returns {\em true} (i.e. the weakest invariant) iff any counterexample in $\Gamma$ evaluates the
relation to false --- this effectively simulates the Houdini approach \cite{houdini}.
Similarly, in case of a \recursiveRelation{} $l_1 \indEq{} l_2$, {\em StrongestInvCover($\Gamma$)}
returns {\em true} iff any counterexample in $\Gamma$ evalutes its $\eta$-depth over-approximation
$l_1 \indEqDepth{\eta} l_2$ to false, where $\eta$ is a fixed parameter of the algorithm.


\subsection{Points-to Analysis}
\label{sec:pointsToFormal}
We formulate our points-to analysis as a dataflow analysis as discussed below.
We first identify the set $\mathcal{R}$ of all region labels representing mutually non-overlapping
regions of the $C$ memory state \mem{}.
For each call to {\tt malloc()} at PC $A$, we add $A_1$ and $A_{2+}$ to $\mathcal{R}$. $\mathcal{R} = \bigcup_{A} \{ A_1, A_{2+} \} \cup \{ \mathcal{H} \}$,
where $\mathcal{H}$ represents the region of memory \mem{} not covered by the region labels associated with allocation sites.

Let $\mathcal{S}_C$ be the set of all scalar pseudo-registers (i.e. variables) in $C$'s IR.
We use a forward dataflow analysis to identify a may-point-to Function
$\Delta: (\mathcal{S}_C \cup \mathcal{R}) \mapsto 2^{\mathcal{R}}$ at each program point.
For an IR instruction ${\tt x} \coloneqq {\tt c}$, for constant {\tt c}, the
transfer function updates $\Delta({\tt x}) \coloneqq \emptyset$.
For instruction ${\tt x} \coloneqq {\tt y\ op\ z}$ (for some arithmetic or logical operator {\tt op}),
we update $\Delta({\tt x}) \coloneqq \Delta({\tt y}) \cup \Delta({\tt z})$.
For a load instruction ${\tt x} \coloneqq \memRead{\mem{}}{y}{T}$, we
update $\Delta({\tt x}) \coloneqq \bigcup_{R \in \Delta(y)} \Delta(R)$.
For a store instruction $\mem{} \coloneqq \memWrite{\mem{}}{x}{y}{T}$, for all
$R \in \Delta({\tt x})$, we update $\Delta(R) \coloneqq \Delta(R) \cup \Delta(y)$.
For a malloc instruction ${\tt x} \coloneqq {\tt malloc}_A()$
(where $A$ represents the allocation site), we perform the following steps (in order):
\begin{enumerate}
\item Convert all existing occurrences of $A_1$ to $A_{2+}$, i.e., for all $R \in \mathcal{S}_C \cup \mathcal{R}$, if $A_1 \in \Delta(R)$, then update $\Delta(R) \coloneqq (\Delta(R) \setminus \{ A_1 \}) \cup \{ A_{2+} \}$.
\item Update $\Delta({\tt x}) \coloneqq \{ A_1 \}$.
\item Update $\Delta(A_{2+}) \coloneqq \Delta(A_{2+}) \cup \Delta(A_1)$.
\item Update $\Delta(A_1) \coloneqq \emptyset$.
\end{enumerate}

The meet operator is set-union.
For a C program $C$, the boundary condition at entry is given by
$\Delta^{start}(R) = \mathcal{R}$ for all $R \in \mathcal{R}$ ($\top$ otherwise).

In case of a deconstruction program $D$, the domain of $\Delta$ is expanded to $(\mathcal{S}_C \cup \mathcal{S}_D \cup \mathcal{R})$,
where $\mathcal{S}_D$ represents the set of all scalar pseudo-registers in $D$'s IR.
Let $\Delta^n_P$ represent the may-point-to function for the program $P$ at node $n$.
Then, for a deconstruction program $D$ originating from a proof obligation
at a product-CFG node $(n_S:n_C)$, the boundary condition is given by:

\begin{center}
\begin{tabular}{rll}
$\Delta^{start}_D(R)=$ & $\Delta^{n_C}_C(R)$ & for all $R \in \mathcal{S}_C \cup \mathcal{R}$ \\
& $\top$ & for all $R \in \mathcal{S}_D$ \\
\end{tabular}
\end{center}

Hence, for a deconstruction program, we use the results of the points-to analysis on $C$ at the PC where
the proof obligation is being discharged. This is a crucial step for proving equality of $C$ values
under different $C$ memory state as seen in \cref{sec:pointsToAsInvariants}.

We run our points-to dataflow analysis on the CFGs of the C program and the deconstruction programs.
For procedure calls, a {\em supergraph} is created by adding control flow edges
from the call-site to the procedure head (copying actual arguments to the formal arguments) and
from the procedure exit to the program point just after the
call-site (copying returned value to the variable assigned at the callsite),
e.g., in \cref{fig:recons}, the dashed edges represent supergraph edges.

The allocation-site abstraction (with a bounded-depth call stack) is
known to be effective at disambiguating memory regions belonging to
different data structures
\cite{allocationSiteAbstraction82,allocationSiteAbstraction90,allocationSiteAbstraction06}.
In our work, we also need to reason about non-aliasing
of the most-recently allocated object (through a {\tt malloc} call) and
the previously-allocated objects (as in the {\tt List}
construction example). The coarse-grained $\{1, 2+\}$
categorization of allocation recency is effective for such
disambiguation.