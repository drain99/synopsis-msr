\section{Spec-to-C Equivalence Checker}
\label{sec:spectocalgo}
In this section, we describe our automatic equivalence checker algorithm \toolName{}.
\toolName{} is able to search for and (hopefully) find a bisimulation based proof of equivalence
between a \SpecL{} and C procedure.
As described in \cref{sec:contribs}, \toolName{} is based on three primary algorithms:
(a) an algorithm to incrementally construct a product-CFG by correlating program executions across
the \SpecL{} and C procedures respectively,
(b) an algorithm to identify inductive invariants at intermediate PCs in the (partially constructed)
product-CFG, and (c) an algorithm for solving proof obligations generated by the first two algorithms.
The last section illustrates our proof discharge algorithm through sample \SpecL{} and C programs.
We start by describing our counterexample-guided best-first search algorithm for
construction of a product-CFG in \cref{sec:searchalgo}.
This is followed by a description of our counterexample-guided invariant inference algorithm in \cref{sec:invinferalgo}.
We finish with a comprehensive analysis of our proof discharge algorithm and its related subprocedures.

\subsection{Counterexample-guided Product-CFG Construction}
\label{sec:searchalgo}
\toolName{} constructs a product-CFG incrementally to search for an observably-equivalent
bisimulation relation between the individual CFGs of a \SpecL{} program $S$ and a C program $C$.
Multiple candidate product-CFGs are partially constructed during this search;
the search completes when one of these candidates yield an equivalence proof.

{\em Anchor nodes}\footnote{XXX:anchor nodes in $S$ as well?} in the CFG of the $C$ program are identified to ensure that every cycle in the CFG
contains at least one anchor node. Also, for every procedure call in the CFG, anchor nodes
are created just before and just after the callsite, e.g., in \cref{fig:llAllocCCFG}, \cpc{4} and \cpc{5} are anchor
nodes around the call to {\tt malloc}.
Our search algorithm ensures that for each anchor node in $C$, we identify a correlated node in $S$ --- if
a product-CFG $\pi$ contains a product-CFG node  $(n_S\!:\!n_C)$, then $\pi$
correlates node $n_C$ in $C$ with node $n_S$ in $S$.
The search procedure begins with a single partially-constructed product-CFG $\pi_0$.
$\pi_0$ contains exactly one node \scpc{0}{0} that encodes the correlation of the entry nodes
(i.e. \spc{0} and \cpc{0}) of the two input CFGs.

At each step of the incremental construction process, a node $(n_S\!:\!n_C)$ is chosen in a product-CFG $\pi$
and a path $\rho_C$ in $C$'s CFG starting at $n_C$ (and ending at an anchor node in $C$) is selected.
Then, we enumerate the potential correlations of the path $\rho_C$ in the $S$'s CFG.
For example, during construction of the product-CFG shown in \cref{fig:llAllocProductCFG},
say we select the product-CFG node \scpc{3}{3}.
We select the $C$ path \cpath{3,4} and enumerate its potential correlations (i.e. paths in $S$ starting at \spc{3}):
$\epsilon$, \spath{3,5}, \spath{3,5,3}, \spath{3,5,3,5},\ldots (up to an unroll factor $\mu$)\footnote{XXX:talk about $\mu$ and pathset?}.

For each enumerated correlation possibility $(\rho_S,\rho_C)$, a separate product-CFG $\pi'$ is
created (by cloning $\pi$) and a new product-CFG edge $e=(\rho_S,\rho_C)$ is added to $\pi'$.
The head of the product-CFG edge $e$ is the (potentially newly added) product-CFG node representing
the correlation of the end-points of paths $\rho_S$ and $\rho_C$. For example, the node {\tt (S3:C4)} is added
to the product-CFG if it correlates paths $\epsilon$ and \cpath{3,4} starting at (\scpc{3}{3}).
For each node $s$ in a product-CFG $\pi$, we maintain a small number of
concrete machine state pairs (of $S$ and $C$) at $s$.
The concrete machine state pairs at $s$ are obtained as counterexamples to an unsucessful proof
obligation \hoareTriple{\phi_s}{s \rightarrow d}{\phi_d} (for some edge $s \rightarrow d$ and node $d$ in $\pi$).
Thus, by construction, these counterexamples represent concrete state pairs that may potentially occur
at $s$ during the lockstep execution encoded by $\pi$.

To evaluate the promise of a possible correlation $(\rho_S,\rho_C)$ starting at node $s$
in product-CFG $\pi$, we examine the execution behavior of the counterexamples at $s$ on
the product-CFG edge $e=(s\rightarrow d)=(\rho_S,\rho_C)$.
If the counterexamples ensure that the machine states remain related at $d$,
then that candidate correlation is ranked higher.
This ranking criterion is based on prior work \cite{oopsla20}.
A best-first search (BFS) procedure based on this ranking criterion is used to incrementally construct
a product-CFG (starting from $\pi_0$) that proves bisimulation.
For each intermediate candidate product-CFG $\pi$ generated during this search procedure,
an automatic invariant inference procedure (discussed next in \cref{sec:invinferalgo}) is
used to identify invariants at all the nodes in $\pi$.
The counterexamples obtained from the proof obligations generated by this invariant inference
procedure are added to the respective nodes in $\pi$; these counterexamples help rank
future correlations starting at those nodes.

If after invariant inference, we realize that an intermediate candidate product-CFG $\pi_1$
is not promising enough, we backtrack and choose another candidate product-CFG $\pi_2$
and explore the potential correlations that can be added to $\pi_2$.
Thus, a product-CFG is constructed one edge at a time.
If at any stage, the invariants inferred for a product-CFG $\pi$ ensure equal observables,
we have successfully shown equivalence.
This counterexample-guided BFS procedure is similar to the one described in prior work on
the Counter algorithm \cite{oopsla20}

\subsubsection{Correlation in the Presence of Procedure Calls}
\label{sec:correlfcalls}
Recall that a procedure $\delta$ in $S$ or $C$ may make calls to other procedures (including self calls),
e.g., allocation of memory in C, traversal of a tree data structure.
Calls to memory allocation functions in $C$ (i.e. {\tt malloc}) are handled by correlating
the function call edge with the empty path ($\epsilon$) in $S$.
For example, in the product-CFG shown in \cref{fig:llAllocProductCFG}, the {\tt malloc} edge \cpath{4,5} in $C$
is correlated with $\epsilon$ in $S$.

For all other procedure calls, our correlation algorithm (in \cref{sec:searchalgo}) ensures that the anchor nodes
around such a callsite are correlated one-to-one across both procedures.
For example, let there be a call to procedure $\delta'$ in $S$ at PC $n_S$, i.e. $n_S$ is the call-site.
Let us denote the program point just after this call-site as $n'_S$.
Let {\tt args}$_{n_S}$ represent the values of the actual arguments of this procedure call (at $n_S$).
Let {\tt ret}$_{n'_S}$ represent the value returned by this procedure call (at $n'_S$).
Similarly, for a procedure call $\delta'$ in $C$, let $n_C$, $n'_C$, {\tt args}$_{n_C}$ and {\tt ret}$_{n'_C}$
represent the procedure call call-site, program point just after call-site,
the values of the actual arguments and the value returned respectively.
Our algorithm ensures that the only correlation possible in a product-CFG $\pi$ for these program points are
$(n_S:n_C)$ and $(n'_S:n'_C)$.

We utilize the user-supplied input-output specification for $\delta'$ (say $(Pre_{\delta'},Post_{\delta'})$)
to obtain the desired invariants at nodes $(n_S:n_C)$ and $(n'_S:n'_C)$ in the product-CFG.
A successful proof must {\em ensure} that $Pre_{\delta'}$({\tt args}$_{n_S}$,{\tt args}$_{n_C}$,$\mem{}_{n_C}$)
holds at $(n_S:n_C)$.
Further, the proof can {\em assume} that $Post_{\delta'}$({\tt ret}$_{n'_S}$,{\tt ret}$_{n'_C}$,$\mem{}_{n'_C}$)
holds at $(n'_S:n'_C)$.
Here, $\mem{}_{n_C}$ and $\mem{}_{n'_C}$ represents the memory states in $C$ at $n_C$ and $n'_C$ respectively.
Thus, for a procedure call, we inductively prove the precondition (on the arguments of the procedure call) at $(n_S:n_C)$
and assume the postcondition (on the return values of the procedure call) at $(n'_S:n'_C)$.

\input{chapters/figures/figInvariantDFA.tex}
\input{chapters/figures/figTfAndInvGrammar.tex}

\subsection{Invariant Inference and Counterexample Generation}
\label{sec:invinferalgo}
We formulate our counterexample-guided invariant inference algorithm as a dataflow analysis
as shown in \cref{tab:dataflow_formulation}.
The invariant inference procedure is responsible for inferring invariants $\phi_n$ at each intermediate
node $n$ of a (partially constructed) product-CFG, while also generating a set of counterexamples
$\Gamma_n$ that represents the potential concrete machine states at $n$.

Given the invariants and counterexamples at node $s$: ($\phi_s,\Gamma_s$),
the transfer function initializes the new candidate set of counterexamples at $d$ ($\Gamma^{can}_{d}$)
with the current set of counterexamples at $d$ ($\Gamma_{d}$) {\em union}-ed with
the counterexamples obtained by executing $\Gamma_s$ on edge $e$ ({\tt exec}$_e$).
The candidate invariant at $d$ ($\phi^{can}_d$) is computed as the strongest cover
of $\Gamma^{can}_{d}$ ($StrongestInvCover()$).
At each step, the transfer function attempts to prove $\{\phi_s\} (e) \{\phi^{can}_d\}$
(through a call to $Prove()$).
If the proof succeeds ($Prove()$ returns true), the candidate invariant $\phi^{can}_d$ is returned alongwith
the counterexamples $\Gamma^{can}_d$ learned so far.
Else the candidate invariant $\phi^{can}_d$ is weakened using the counterexamples obtained
(i.e. $\gamma_s$) and the proof attempt is repeated.

The candidate invariants are drawn from the predicate grammar shown in \cref{fig:invGrammar}.
The predicate grammar allows affine and inequality relations between bitvector values of both
programs, as well as, \recursiveRelations{} between an ADT value in \SpecL{} and a {\em lifted} ADT value in $C$.
The candidate lifting constructors are derived from the lifting constructors
present in the precondition $Pre$ and the position $Post$, as supplied by the user.
More sophisticated strategies for deduction of new lifting constructors is possible.

{\em StrongestInvCover()} for affine relations involve
identifying the basis vectors of the kernel of the
matrix formed by the counterexamples in the bitvector
domain \cite{esop05,semalign}.
For inequality relations, {\em StrongestInvCover($\Gamma$)}
returns false iff any counterexample in $\Gamma$ evaluates the
relation to false --- this effectively simulates the Houdini approach \cite{houdini}.
In case of a \recursiveRelation{} $l_1 \indEq{} l_2$, {\em StrongestInvCover($\Gamma$)}
returns false\footnote{XXX: isn't false the strongest? shouldn't we return true???} iff any counterexample in $\Gamma$ evalutes its $\eta$-depth over-approximation
$l_1 \indEqDepth{\eta} l_2$ to false, where $\eta$ is a fixed parameter of the algorithm.


\subsection{Points-to Analysis}
\label{sec:pointsToFormal}
We formulate our points-to analysis as a dataflow analysis as discussed below.
We first identify the set $R_C$ of all region labels representing mutually non-overlapping
regions of the $C$ memory state \mem{}.
For each call to {\tt malloc()} at PC $A$, we add $A_1$ and $A_{2+}$ to $R_C$. $R_C=\bigcup_{A}\{A_1,A_{2+}\}\cup\{ \mathcal{H} \}$,
where $\mathcal{H}$ represents the region of memory \mem{} not covered the region labels associated with allocation sites.

Let $S_{C}$ be the set of all scalar pseudo-registers in $C$'s
IR. We use a forward dataflow
analysis to identify a may-point-to function $\Delta: (S_{C}\cup{}R_C) \mapsto 2^{R_C}$
at each program point.
For an IR instruction {\tt x := c}, for constant $c$, the
transfer function updates $\Delta({\tt x}) := \emptyset$.
For instruction {\tt x := y op z} (for some arithmetic
or logical operand {\tt op}),
we update $\Delta({\tt x}) := \Delta({\tt y})\cup\Delta({\tt z})$.
For a
load instruction {\tt x := *y}, we
update $\Delta({\tt x})$ to $\bigcup_{R_C\in\Delta(y)}\Delta(R_C)$.
For a store instruction {\tt *x := y}, for all
$R_C\in\Delta({\tt x})$, we update $\Delta(R_C) := \Delta(R_C)\cup\Delta(y)$.
For recursive procedure calls, a {\em supergraph}
is created by adding control flow edges
from the call-site to the procedure head (copying actual arguments
to the formal arguments) and from the procedure exit
to the program point just after the call-site (copying returned
value to the variable assigned at the callsite), e.g., in
\cref{fig:recons}, the dashed edges
represent supergraph edges.
For a malloc instruction {\tt x := malloc$_A$()} (where $A$
represents the allocation site), we perform the following steps (in order):
% (a) Convert all existing occurrences of $A_1$ to $A_{2+}$, i.e., for all $r\in{}S\cup{}R$, if $A_1\in\Delta(r)$, then update $\Delta(r) := (\Delta(r)\setminus\{A_1\})\cup\{A_{2+}\}$;
% (b) Update $\Delta({\tt x}) := \{A_1\}$;
% (c)Update $\Delta(A_{2+}) := \Delta(A_{2+})\cup\Delta(A_1)$;
% (d) Update $\Delta(A_1) := \emptyset$ (empty set).
\begin{enumerate}
\item Convert all existing occurrences of $A_1$ to $A_{2+}$, i.e., for all $r\in{}S_C\cup{}R_C$, if $A_1\in\Delta(r)$, then update $\Delta(r) := (\Delta(r)\setminus\{A_1\})\cup\{A_{2+}\}$.
\item Update $\Delta({\tt x}) := \{A_1\}$
\item Update $\Delta(A_{2+}) := \Delta(A_{2+})\cup\Delta(A_1)$.
\item Update $\Delta(A_1) := \emptyset$ (empty set).
\end{enumerate}

The meet operator is set-union.
For a C program $C$, the boundary condition at entry is given by
$\Delta_C^{entry}(r)=R_C$ for all $r\in{}S_C\cup{}R_C$,
where $\Delta_P^{pc}$ represents the may-point-to function
for program $P$ at PC $pc$.

In case of a reconstruction program $R$, the domain of $\Delta$ contains the pseudo-registers in $C$'s IR ($S_C$) as well as
any region labels ($R_C$). In addition to these, the domain also contains the pseudo-registers
of the reconstruction program itself, say $R_R$. For a reconstruction program $R$ originating from a proof obligation
at a product program PC $(n_S,n_C)$, the boundary condition is given by:

\begin{center}
\begin{tabular}{rll}
$\Delta^{entry}_R(r)=$ & $\Delta^{n_C}_C(r)$ & $\mathrm{for\ all}\ r \in{}S_C\cup{}R_C$ \\
& $\emptyset$ & $\mathrm{for\ all}\ r \in{}R_R$ \\
\end{tabular}
\end{center}

Hence, for a reconstruction program, we use the results of the points-to analysis on $C$ at the PC where
the proof obligation is being discharged. This is a crucial step for proving equality of $C$ values
under different $C$ memory state as seen in \cref{sec:pointsToAsInvariants}.

The allocation-site abstraction (with a bounded-depth call stack) is
known to be effective at disambiguating memory regions belonging to
different data structures
\cite{allocationSiteAbstraction82,allocationSiteAbstraction90,allocationSiteAbstraction06}.
In our work, we also need to reason about non-aliasing
of the most-recently allocated object (through a {\tt malloc} call) and
the previously-allocated objects (as in the {\tt List}
construction example). The coarse-grained $\{1, 2+\}$
categorization of allocation recency is effective for such
disambiguation.