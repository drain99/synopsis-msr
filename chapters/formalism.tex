\section{Formalism}
\label{sec:formalism}
\subsection{The \SpecL{} Language}
\label{sec:speclang}
We briefly discuss the properties of the \SpecL{} language in this section.
\SpecL{} supports recursive algebraic data types (ADT) similar to the ones available in most functional languages.
The types in \SpecL{} can be represented in {\em first order recursive types} with {\tt Product} and {\tt Sum}
type constructors and {\tt Unit, Bool, i<N>} types (i.e., nullary type constructors) as follows:

$T \rightarrow {\tt \mu} \alpha \ |\  {\tt Product}(T,\dots,T) \ |\  {\tt Sum}(T,\dots,T) \ |\  {\tt Unit} \ |\ {\tt Bool} \ |\  {\tt i\langle N \rangle} \ |\  \alpha$

For example, the {\tt List} type can be written as $\mu \alpha. Sum(Unit, Prod(i32,\alpha))$.

The language also borrows its expression grammar heavily from functional languages.
This includes the usual constructs like {\tt let-in}, {\tt if-then-else}, function application and the {\tt match} statement
for pattern-matching (i.e. deconstructing) sum and product values.
Unlike functional languages, \SpecL{} only supports first order functions.
Also, \SpecL{} does not support partial function application.
Hence, we constrain our attention to C programs containing only first order functions.
\SpecL{} is equipped with a special {\tt assuming-do} construct for explicitly providing UB conditions.
These assumptions become part of ($S$\ \ {\tt def}) as discussed in \cref{sec:eqdef}.
\SpecL{} also provides the typical boolean and bitvector operators for expressing computation in C succintly yet explicitly.
This includes logical operators (e.g., {\tt and}), bitvector arithmatic operators (e.g., {\tt bvadd(+)}) and
relational operators for comparing bitvectors interpreted as signed or unsigned integers (e.g., {\tt $\leq_{u,s}$}).

\begin{figure}[H]
\begin{small}
\begin{tabular}{rcl}
\NonTerm{expr} & $\rightarrow$ & \Term{if} \NonTerm{expr} \Term{then} \NonTerm{expr} \Term{else} \NonTerm{expr} \\
& $|$ & \Term{let} \NonTerm{id} \Term{=} \NonTerm{expr} \Term{in} \NonTerm{expr} \\
& $|$ & \Term{match} \NonTerm{expr} \Term{with} \NonTerm{match-clause-list} \\
& $|$ & \Term{assuming} \NonTerm{expr} \Term{do} \NonTerm{expr} \\
& $|$ & \NonTerm{id} \Term{(} \NonTerm{expr-list} \Term{)} \\
& $|$ & \NonTerm{data-cons} \Term{(} \NonTerm{expr-list} \Term{)} \\
& $|$ & \NonTerm{expr} \Term{is} \NonTerm{data-cons} \\
& $|$ & \NonTerm{expr} \NonTerm{scalar-op} \NonTerm{expr} \\
& $|$ & \NonTerm{literal$_{\mathrm{Unit}}$} $|$ \NonTerm{literal$_{\mathrm{Bool}}$} $|$ \NonTerm{literal$_{\mathrm{i<N>}}$} \\
\\
\NonTerm{match-clause-list} & $\rightarrow$ & \NonTerm{match-clause}$^*$ \\
\NonTerm{match-clause} & $\rightarrow$ & \Term{$|$} \NonTerm{data-cons} \Term{(} \NonTerm{id-list} \Term{)} \Term{$\Rightarrow$} \NonTerm{expr} \\
\NonTerm{expr-list} & $\rightarrow$ & \Term{$\epsilon$} \Term{$|$} \NonTerm{expr} \Term{,} \NonTerm{expr-list} \\
\NonTerm{id-list} & $\rightarrow$ & \Term{$\epsilon$} \Term{$|$} \NonTerm{id} \Term{,} \NonTerm{id-list} \\
\\
\NonTerm{literal$_{\mathrm{Unit}}$} & $\rightarrow$ & \Term{()} \\
\NonTerm{literal$_{\mathrm{Bool}}$} & $\rightarrow$ & \Term{false} $|$ \Term{true} \\
\NonTerm{literal$_{\mathrm{i<N>}}$} & $\rightarrow$ & [\Term{0$\dots$2$^{\mathrm{N}}$-1}] \\
\end{tabular}
\end{small}
\caption{\label{fig:specgrammar}Simplified expression grammar of \SpecL{} language}
\end{figure}

\subsection{Counterexample-Guided Best-First Search Algorithm for a Product-CFG}
\label{sec:searchAlgoFormal}

\toolName{} constructs a product-CFG incrementally to search for
an observably-equivalent bisimulation relation between
the individual CFGs of a \SpecL{} program $S$ and a C program $C$.
Multiple candidate product-CFGs are partially constructed
during this search; the search completes when one of these
candidates yields an equivalence proof.

{\em Anchor nodes} in the CFG of the $C$ program
are identified to ensure that every cycle in the CFG
contains at least one anchor node. Also, for
every procedure call in the CFG, anchor nodes
are created just before and just after the callsite, e.g.,
in \cref{fig:llAllocCCFG}, {\tt C4} and {\tt C5} are anchor
nodes around the call to {\tt malloc()}.
Our algorithm
ensures that for each anchor node in $C$, we
identify a correlated node in $S$ --- if
a product-CFG $\pi$
contains a product-CFG node $(n_S,n_C)$, then $\pi$
correlates node $n_C$
in $C$ with node $n_S$ in $S$.
The
first partially-constructed product-CFG
contains a single entry node
that encodes the correlation of the entry nodes ({\tt S0:C0})
of the two input CFGs.

At each step of the incremental construction algorithm,
a node $(n_S,n_C)$ is chosen in a product-CFG $\pi$
and a path $\rho_C$ in $C$'s CFG starting at $n_C$ (and
ending at an anchor node in $C$) is selected.
Then, the potential correlations $\rho_C$
with paths
in $S$'s CFG are enumerated.
For
example, in \cref{fig:llAllocProductCFG}, at product-CFG
node {\tt (S3:C3)}, we first select the $C$ path {\tt C3$\rightarrow$C4},
and its potential correlation possibilities
with paths $\epsilon$, ${\tt S3\rightarrow{}S5}$, ${\tt S3\rightarrow{}S5\rightarrow{}S3}$, ${\tt S3\rightarrow{}S5\rightarrow{}S3\rightarrow{}S5}$, ... in $S$ are enumerated (up to an unroll factor $\mu$).

For each enumerated correlation possibility $(\rho_S,\rho_C)$,
a separate
product-CFG $\pi'$ is created (by cloning $\pi$)
and a new product-CFG
edge $e=(\rho_S,\rho_C)$ is added to $\pi'$.
The head of the product-CFG edge $e$ is the
(potentially newly added) product-CFG node representing
the correlation of the end-points of paths $\rho_S$
and $\rho_C$. For example, the node {\tt (S3:C4)} is added
to the product-CFG if it correlates paths $\epsilon$ and ${\tt C3\rightarrow{}C4}$
starting at {\tt (S3:C3)}.
For each node $s$ in a product-CFG $\pi$, we maintain
a small number of
concrete machine state pairs (of $S$ and $C$) at $s$.
The concrete
machine state pairs at $s$
are obtained as
counterexamples to an unsucessful proof
obligation $\{\phi_s\} (s \rightarrow d) \{\phi_d\}$ (for
some edge $s \rightarrow d$ and node $d$ in $\pi$).
Thus, by construction, these counterexamples represent
concrete state pairs that
may potentially occur
at $s$ during the lockstep execution encoded
by $\pi$.

To evaluate the promise of a possible correlation
$(\rho_S,\rho_C)$ starting at node $s$
in product-CFG $\pi$,
we examine the execution
behavior of the counterexamples at $s$ on
the product-CFG edge $e=(s\rightarrow d)=(\rho_S,\rho_C)$.
If the counterexamples ensure that the machine
states remain
related at $d$, then that candidate correlation
is ranked higher.
This ranking criterion is based on prior work \cite{oopsla20}.
A best-first search (BFS) procedure based on this ranking
criterion is used to incrementally construct
a product-CFG that proves bisimulation.
For each intermediate candidate product-CFG $\pi$ generated
during this search procedure,
an automatic invariant inference procedure is used
to identify invariants at all the nodes in $\pi$.
The counterexamples
obtained from the proof obligations created
by this invariant inference procedure are added to the
respective nodes in $\pi$; these counterexamples
help rank future correlations starting at those
nodes.

If after invariant inference,
we realize that an intermediate candidate product-CFG $\pi_1$
is not promising enough,
we backtrack and choose another
candidate product-CFG $\pi_2$ and explore the potential correlations that
can be added to $\pi_2$.
Thus, a product-CFG is constructed one edge at a time.
If at any stage, the invariants inferred for a product-CFG
$\pi_i$ ensure equal
observables, we have successfully demonstrated equivalence.

This counterexample-guided BFS procedure
is similar to the one described in prior work on
the Counter algorithm \cite{oopsla20}. Our
primary contribution is a proof discharge
algorithm for proof obligations containing
\recursiveRelations{}
(\cref{sec:proofObligations,sec:proofDischarge,sec:cat1,sec:cat2,sec:cat3}).
These proof obligations may
be generated either at the intermediate (search) or
the final (check)
phases of the BFS procedure.
%The use of
%a precise-enough alias analysis in C is an important part of this
%contribution.

\input{chapters/figures/figInvariantDFA.tex}
\input{chapters/figures/figTfAndInvGrammar.tex}

\subsection{Invariant Inference and Counterexample Generation}
\label{sec:invinference}

\Cref{tab:dataflow_formulation} presents our dataflow analysis for inferring invariants $\phi_n$
at each node $n$ of a product-CFG, while also generating a set of counterexamples $\Gamma_n$ at node $n$
that represents the potential concrete machine states at $n$.

Given the invariants and counterexamples at node $s$
($\phi_s,\Gamma_s$),
the transfer function initializes the new candidate set
of counterexamples at $d$ ($\Gamma^{can}_{d}$)
to the current set of counterexamples at $d$ ($\Gamma_{d}$) union-ed with
the counterexamples obtained by executing $\Gamma_s$ on edge $e$ ({\tt exec$_e$}).
The candidate invariant at $d$ ($\phi^{can}_d$) is computed
as the strongest cover of $\Gamma^{can}_{d}$ ({\em StrongestInvCover()}).
At each step, the transfer function attempts to prove
$\{\phi_s\} (e) \{\phi^{can}_d\}$ (by checking {\tt SAT}isfiability of its
negation). If the proof succeeds, the candidate invariant $\phi^{can}_d$ is
returned alongwith the counterexamples $\Gamma^{can}_d$ learned so far.
Else the candidate invariant $\phi^{can}_d$ is weakened using
the counterexamples obtained from the {\tt SAT} query ($\gamma$) and the proof attempt is
repeated.

The predicate grammar allows the automatic inference of
affine and inequality relations between bitvector values of both
programs, as well as, \recursiveRelations{} between an ADT value in \SpecL{} ($\alpha_S$)
and a {\em lifted} ADT value from C (${\tt liftC}_m(p_C)$).
We enumerate these \recursiveRelation{}
guesses for all bitvector variables $v^{C}$ in $C$ and candidate {\tt liftC} lifting constructor.
In our implementation, the candidate
{\tt liftC}
constructors are derived from the constructors
present in the precondition $Pre$
and the postcondition $Post$.  More
sophisticated strategies for automatic guessing of
these lifting constructors
are possible.

{\em StrongestInvCover()} for affine relations involves
identifying the basis vectors of the kernel of the
matrix formed by the counterexamples in the bitvector
domain \cite{esop05,semalign}.
For inequality relations, {\em StrongestInvCover($\Gamma$)}
returns false iff any counterexample in $\Gamma$ evaluates the
relation to false --- this effectively simulates the Houdini approach \cite{houdini}.
In case of \recursiveRelations{}, {\em StrongestInvCover($\Gamma$)}
attempts to disprove the \recursiveRelation{} $l_1 \indEq{} l_2$ by evaluating
its depth-$\eta$ under-approximation $l_1 \indEqDepth{\eta} l_2$ for each counterexample
in $\Gamma$ and returns false if any one of them successfully evaluates to false.
$\eta$ is a constant parameter of the algorithm.

\subsection{Modeling Procedure Calls}
\label{sec:modelfcalls}
A top-level procedure $\delta$
in $S$ or $C$ may make non-tail recursive
calls, e.g., for traversing
a tree data structure.
Our correlation algorithm (\cref{sec:searchAlgoFormal}) ensures
that the anchor nodes around such a callsite are correlated
one-to-one across both programs. For example, let there be a
recursive call in $S$ at PC $A_S$, i.e., $A_S$ is the callsite.
Then we denote the program points just before and just
after this callsite
as $A^{{\tt b}}_S$ and $A^{{\tt a}}_S$ respectively.
Let {\tt args$_{A_S}$}
represent the values of the
actual arguments of this procedure call.
Let {\tt ret$_{A_S}$} represent the values returned by this procedure call.
Similarly, for a procedure call at PC $A_C$ in $C$, let
$A^{{\tt b}}_C$,
$A^{{\tt a}}_C$,
{\tt args$_{A_C}$} and {\tt ret$_{A_C}$} 
represent the before-callsite program point, after-callsite program point,
arguments and return values respectively.
Our algorithm ensures that the only correlations possible in
a product-CFG $\pi$ for these $S$ and $C$ program points are
{\tt $A_{\pi}^{{\tt b}}$=($A_{S}^{{\tt b}}$,$A_{C}^{{\tt b}}$)}
and
{\tt $A_{\pi}^{{\tt a}}$=($A_{S}^{{\tt a}}$,$A_{C}^{{\tt a}}$)}.

Recall that the recursive call at $A_S$ (or $A_C$) must
be a call to the top-level procedure $\delta$.
We utilize the user-supplied $Pre$ and $Post$ conditions for $\delta$ to obtain
the desired invariants at nodes $A_{\pi}^{{\tt b}}$
and 
$A_{\pi}^{{\tt a}}$ in the product-CFG.
We require a successful proof to
{\em ensure} that {\small $Pre(A^{{\tt args_S}}_S, A^{{\tt args_C}}_C, m_{\tt b})$}
holds at $A_{\pi}^{{\tt b}}$.  Further, the proof can
{\em assume} that {\small $Post(A^{{\tt ret_S}}_S, A^{{\tt ret_C}}_C, m_{\tt a})$} holds
at 
$A_{\pi}^{{\tt a}}$. Here, $m_{\tt b}$
and $m_{\tt a}$ represent the memory states in $C$ at
$A^{{\tt b}}_C$ and
$A^{{\tt a}}_C$ respectively.
Thus, for such recursive calls to the
top-level function, we inductively
prove the precondition (on the
arguments of the procedure call) at $A_{\pi}^{{\tt b}}$
and assume the postcondition (on the return values of the procedure call)
at $A_{\pi}^{{\tt a}}$.


\subsection{Points-to Analysis}
\label{sec:pointsToFormal}
We first identify the set $R_C$ of all region labels representing mutually non-overlapping
regions of the $C$ memory state $m$.
For each call to {\tt malloc()} at PC $A$,
we add $A_1$ and $A_{2+}$ to $R_C$. $R_C=\bigcup_{A}\{A_1,A_{2+}\}\cup\{{\tt heap}\}$,
where {\tt heap} represents all {\em other} memory regions that are not
captured by the region labels associated with allocation sites.

Let $S_{C}$ be the set of all scalar pseudo-registers in $C$'s
IR. We use a forward dataflow
analysis to identify a may-point-to function $\Delta: (S_{C}\cup{}R_C) \mapsto 2^{R_C}$
at each program point.
For an IR instruction {\tt x := c}, for constant $c$, the
transfer function updates $\Delta({\tt x}) := \emptyset$.
For instruction {\tt x := y op z} (for some arithmetic
or logical operand {\tt op}),
we update $\Delta({\tt x}) := \Delta({\tt y})\cup\Delta({\tt z})$.
For a
load instruction {\tt x := *y}, we
update $\Delta({\tt x})$ to $\bigcup_{R_C\in\Delta(y)}\Delta(R_C)$.
For a store instruction {\tt *x := y}, for all
$R_C\in\Delta({\tt x})$, we update $\Delta(R_C) := \Delta(R_C)\cup\Delta(y)$.
For recursive procedure calls, a {\em supergraph}
is created by adding control flow edges
from the call-site to the procedure head (copying actual arguments
to the formal arguments) and from the procedure
return to the returning point of the call-site (copying returned
value to the variable assigned at the callsite), e.g., in
\cref{fig:recons}, the dashed edges
represent supergraph edges.
For a malloc instruction {\tt x := malloc$_A$()} (where $A$
represents the allocation site), we perform the following steps (in order):
% (a) Convert all existing occurrences of $A_1$ to $A_{2+}$, i.e., for all $r\in{}S\cup{}R$, if $A_1\in\Delta(r)$, then update $\Delta(r) := (\Delta(r)\setminus\{A_1\})\cup\{A_{2+}\}$;
% (b) Update $\Delta({\tt x}) := \{A_1\}$;
% (c)Update $\Delta(A_{2+}) := \Delta(A_{2+})\cup\Delta(A_1)$;
% (d) Update $\Delta(A_1) := \emptyset$ (empty set).
\begin{enumerate}
\item Convert all existing occurrences of $A_1$ to $A_{2+}$, i.e., for all $r\in{}S_C\cup{}R_C$, if $A_1\in\Delta(r)$, then update $\Delta(r) := (\Delta(r)\setminus\{A_1\})\cup\{A_{2+}\}$.
\item Update $\Delta({\tt x}) := \{A_1\}$
\item Update $\Delta(A_{2+}) := \Delta(A_{2+})\cup\Delta(A_1)$.
\item Update $\Delta(A_1) := \emptyset$ (empty set).
\end{enumerate}

The meet operator is set-union.
For a C program $C$, the boundary condition at entry is given by
$\Delta_C^{entry}(r)=R_C$ for all $r\in{}S_C\cup{}R_C$,
where $\Delta_P^{pc}$ represents the may-point-to function
for program $P$ at PC $pc$.

In case of a reconstruction program $R$, the domain of $\Delta$ contains the pseudo-registers in $C$'s IR ($S_C$) as well as
any region labels ($R_C$). In addition to these, the domain also contains the pseudo-registers
of the reconstruction program itself, say $R_R$. For a reconstruction program $R$ originating from a proof obligation
at a product program PC $(n_S,n_C)$, the boundary condition is given by:

\begin{center}
\begin{tabular}{rll}
$\Delta^{entry}_R(r)=$ & $\Delta^{n_C}_C(r)$ & $\mathrm{for\ all}\ r \in{}S_C\cup{}R_C$ \\
& $\emptyset$ & $\mathrm{for\ all}\ r \in{}R_R$ \\
\end{tabular}
\end{center}

Hence, for a reconstruction program, we use the results of the points-to analysis on $C$ at the PC where
the proof obligation is being discharged. This is a crucial step for proving equality of values
under mutating $C$ memory state as seen in \cref{sec:pointsToAsInvariants}.
% A deconstruction
% program does not contain any store and malloc operations.

The allocation-site abstraction (with a bounded-depth call stack) is
known to be effective at disambiguating memory regions belonging to
different data structures
\cite{allocationSiteAbstraction82,allocationSiteAbstraction90,allocationSiteAbstraction06}.
In our work, we also need to reason about non-aliasing
of the most-recently allocated object (through a {\tt malloc} call) and
the previously-allocated objects (as in the {\tt List}
construction example). The coarse-grained $\{1, 2+\}$
categorization of allocation recency is effective for such
disambiguation.